// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"time"

	mock "github.com/stretchr/testify/mock"
	"go.goldmine.build/go/issuetracker/v1"
	"go.goldmine.build/npm-audit-mirror/go/types"
)

// NewNpmDB creates a new instance of NpmDB. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewNpmDB(t interface {
	mock.TestingT
	Cleanup(func())
}) *NpmDB {
	mock := &NpmDB{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// NpmDB is an autogenerated mock type for the NpmDB type
type NpmDB struct {
	mock.Mock
}

type NpmDB_Expecter struct {
	mock *mock.Mock
}

func (_m *NpmDB) EXPECT() *NpmDB_Expecter {
	return &NpmDB_Expecter{mock: &_m.Mock}
}

// GetFromDB provides a mock function for the type NpmDB
func (_mock *NpmDB) GetFromDB(ctx context.Context, key string) (*types.NpmAuditData, error) {
	ret := _mock.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetFromDB")
	}

	var r0 *types.NpmAuditData
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*types.NpmAuditData, error)); ok {
		return returnFunc(ctx, key)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *types.NpmAuditData); ok {
		r0 = returnFunc(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.NpmAuditData)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, key)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// NpmDB_GetFromDB_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFromDB'
type NpmDB_GetFromDB_Call struct {
	*mock.Call
}

// GetFromDB is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *NpmDB_Expecter) GetFromDB(ctx interface{}, key interface{}) *NpmDB_GetFromDB_Call {
	return &NpmDB_GetFromDB_Call{Call: _e.mock.On("GetFromDB", ctx, key)}
}

func (_c *NpmDB_GetFromDB_Call) Run(run func(ctx context.Context, key string)) *NpmDB_GetFromDB_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *NpmDB_GetFromDB_Call) Return(npmAuditData *types.NpmAuditData, err error) *NpmDB_GetFromDB_Call {
	_c.Call.Return(npmAuditData, err)
	return _c
}

func (_c *NpmDB_GetFromDB_Call) RunAndReturn(run func(ctx context.Context, key string) (*types.NpmAuditData, error)) *NpmDB_GetFromDB_Call {
	_c.Call.Return(run)
	return _c
}

// PutInDB provides a mock function for the type NpmDB
func (_mock *NpmDB) PutInDB(ctx context.Context, key string, issueId int64, created time.Time) error {
	ret := _mock.Called(ctx, key, issueId, created)

	if len(ret) == 0 {
		panic("no return value specified for PutInDB")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int64, time.Time) error); ok {
		r0 = returnFunc(ctx, key, issueId, created)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// NpmDB_PutInDB_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutInDB'
type NpmDB_PutInDB_Call struct {
	*mock.Call
}

// PutInDB is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - issueId int64
//   - created time.Time
func (_e *NpmDB_Expecter) PutInDB(ctx interface{}, key interface{}, issueId interface{}, created interface{}) *NpmDB_PutInDB_Call {
	return &NpmDB_PutInDB_Call{Call: _e.mock.On("PutInDB", ctx, key, issueId, created)}
}

func (_c *NpmDB_PutInDB_Call) Run(run func(ctx context.Context, key string, issueId int64, created time.Time)) *NpmDB_PutInDB_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 int64
		if args[2] != nil {
			arg2 = args[2].(int64)
		}
		var arg3 time.Time
		if args[3] != nil {
			arg3 = args[3].(time.Time)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *NpmDB_PutInDB_Call) Return(err error) *NpmDB_PutInDB_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *NpmDB_PutInDB_Call) RunAndReturn(run func(ctx context.Context, key string, issueId int64, created time.Time) error) *NpmDB_PutInDB_Call {
	_c.Call.Return(run)
	return _c
}

// NewChecksManager creates a new instance of ChecksManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewChecksManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *ChecksManager {
	mock := &ChecksManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ChecksManager is an autogenerated mock type for the ChecksManager type
type ChecksManager struct {
	mock.Mock
}

type ChecksManager_Expecter struct {
	mock *mock.Mock
}

func (_m *ChecksManager) EXPECT() *ChecksManager_Expecter {
	return &ChecksManager_Expecter{mock: &_m.Mock}
}

// PerformChecks provides a mock function for the type ChecksManager
func (_mock *ChecksManager) PerformChecks(packageRequestURL string) (bool, string, error) {
	ret := _mock.Called(packageRequestURL)

	if len(ret) == 0 {
		panic("no return value specified for PerformChecks")
	}

	var r0 bool
	var r1 string
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(string) (bool, string, error)); ok {
		return returnFunc(packageRequestURL)
	}
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(packageRequestURL)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(string) string); ok {
		r1 = returnFunc(packageRequestURL)
	} else {
		r1 = ret.Get(1).(string)
	}
	if returnFunc, ok := ret.Get(2).(func(string) error); ok {
		r2 = returnFunc(packageRequestURL)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// ChecksManager_PerformChecks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PerformChecks'
type ChecksManager_PerformChecks_Call struct {
	*mock.Call
}

// PerformChecks is a helper method to define mock.On call
//   - packageRequestURL string
func (_e *ChecksManager_Expecter) PerformChecks(packageRequestURL interface{}) *ChecksManager_PerformChecks_Call {
	return &ChecksManager_PerformChecks_Call{Call: _e.mock.On("PerformChecks", packageRequestURL)}
}

func (_c *ChecksManager_PerformChecks_Call) Run(run func(packageRequestURL string)) *ChecksManager_PerformChecks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ChecksManager_PerformChecks_Call) Return(b bool, s string, err error) *ChecksManager_PerformChecks_Call {
	_c.Call.Return(b, s, err)
	return _c
}

func (_c *ChecksManager_PerformChecks_Call) RunAndReturn(run func(packageRequestURL string) (bool, string, error)) *ChecksManager_PerformChecks_Call {
	_c.Call.Return(run)
	return _c
}

// NewCheck creates a new instance of Check. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCheck(t interface {
	mock.TestingT
	Cleanup(func())
}) *Check {
	mock := &Check{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Check is an autogenerated mock type for the Check type
type Check struct {
	mock.Mock
}

type Check_Expecter struct {
	mock *mock.Mock
}

func (_m *Check) EXPECT() *Check_Expecter {
	return &Check_Expecter{mock: &_m.Mock}
}

// Name provides a mock function for the type Check
func (_mock *Check) Name() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Name")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// Check_Name_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Name'
type Check_Name_Call struct {
	*mock.Call
}

// Name is a helper method to define mock.On call
func (_e *Check_Expecter) Name() *Check_Name_Call {
	return &Check_Name_Call{Call: _e.mock.On("Name")}
}

func (_c *Check_Name_Call) Run(run func()) *Check_Name_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Check_Name_Call) Return(s string) *Check_Name_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *Check_Name_Call) RunAndReturn(run func() string) *Check_Name_Call {
	_c.Call.Return(run)
	return _c
}

// PerformCheck provides a mock function for the type Check
func (_mock *Check) PerformCheck(packageName string, packageVersion string, npmPackage *types.NpmPackage) (bool, string, error) {
	ret := _mock.Called(packageName, packageVersion, npmPackage)

	if len(ret) == 0 {
		panic("no return value specified for PerformCheck")
	}

	var r0 bool
	var r1 string
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(string, string, *types.NpmPackage) (bool, string, error)); ok {
		return returnFunc(packageName, packageVersion, npmPackage)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string, *types.NpmPackage) bool); ok {
		r0 = returnFunc(packageName, packageVersion, npmPackage)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(string, string, *types.NpmPackage) string); ok {
		r1 = returnFunc(packageName, packageVersion, npmPackage)
	} else {
		r1 = ret.Get(1).(string)
	}
	if returnFunc, ok := ret.Get(2).(func(string, string, *types.NpmPackage) error); ok {
		r2 = returnFunc(packageName, packageVersion, npmPackage)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// Check_PerformCheck_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PerformCheck'
type Check_PerformCheck_Call struct {
	*mock.Call
}

// PerformCheck is a helper method to define mock.On call
//   - packageName string
//   - packageVersion string
//   - npmPackage *types.NpmPackage
func (_e *Check_Expecter) PerformCheck(packageName interface{}, packageVersion interface{}, npmPackage interface{}) *Check_PerformCheck_Call {
	return &Check_PerformCheck_Call{Call: _e.mock.On("PerformCheck", packageName, packageVersion, npmPackage)}
}

func (_c *Check_PerformCheck_Call) Run(run func(packageName string, packageVersion string, npmPackage *types.NpmPackage)) *Check_PerformCheck_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *types.NpmPackage
		if args[2] != nil {
			arg2 = args[2].(*types.NpmPackage)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Check_PerformCheck_Call) Return(b bool, s string, err error) *Check_PerformCheck_Call {
	_c.Call.Return(b, s, err)
	return _c
}

func (_c *Check_PerformCheck_Call) RunAndReturn(run func(packageName string, packageVersion string, npmPackage *types.NpmPackage) (bool, string, error)) *Check_PerformCheck_Call {
	_c.Call.Return(run)
	return _c
}

// NewProjectAudit creates a new instance of ProjectAudit. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewProjectAudit(t interface {
	mock.TestingT
	Cleanup(func())
}) *ProjectAudit {
	mock := &ProjectAudit{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ProjectAudit is an autogenerated mock type for the ProjectAudit type
type ProjectAudit struct {
	mock.Mock
}

type ProjectAudit_Expecter struct {
	mock *mock.Mock
}

func (_m *ProjectAudit) EXPECT() *ProjectAudit_Expecter {
	return &ProjectAudit_Expecter{mock: &_m.Mock}
}

// StartAudit provides a mock function for the type ProjectAudit
func (_mock *ProjectAudit) StartAudit(ctx context.Context, pollInterval time.Duration) {
	_mock.Called(ctx, pollInterval)
	return
}

// ProjectAudit_StartAudit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartAudit'
type ProjectAudit_StartAudit_Call struct {
	*mock.Call
}

// StartAudit is a helper method to define mock.On call
//   - ctx context.Context
//   - pollInterval time.Duration
func (_e *ProjectAudit_Expecter) StartAudit(ctx interface{}, pollInterval interface{}) *ProjectAudit_StartAudit_Call {
	return &ProjectAudit_StartAudit_Call{Call: _e.mock.On("StartAudit", ctx, pollInterval)}
}

func (_c *ProjectAudit_StartAudit_Call) Run(run func(ctx context.Context, pollInterval time.Duration)) *ProjectAudit_StartAudit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 time.Duration
		if args[1] != nil {
			arg1 = args[1].(time.Duration)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ProjectAudit_StartAudit_Call) Return() *ProjectAudit_StartAudit_Call {
	_c.Call.Return()
	return _c
}

func (_c *ProjectAudit_StartAudit_Call) RunAndReturn(run func(ctx context.Context, pollInterval time.Duration)) *ProjectAudit_StartAudit_Call {
	_c.Run(run)
	return _c
}

// NewProjectMirror creates a new instance of ProjectMirror. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewProjectMirror(t interface {
	mock.TestingT
	Cleanup(func())
}) *ProjectMirror {
	mock := &ProjectMirror{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ProjectMirror is an autogenerated mock type for the ProjectMirror type
type ProjectMirror struct {
	mock.Mock
}

type ProjectMirror_Expecter struct {
	mock *mock.Mock
}

func (_m *ProjectMirror) EXPECT() *ProjectMirror_Expecter {
	return &ProjectMirror_Expecter{mock: &_m.Mock}
}

// AddToDownloadedPackageTarballs provides a mock function for the type ProjectMirror
func (_mock *ProjectMirror) AddToDownloadedPackageTarballs(packageTarballName string) {
	_mock.Called(packageTarballName)
	return
}

// ProjectMirror_AddToDownloadedPackageTarballs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddToDownloadedPackageTarballs'
type ProjectMirror_AddToDownloadedPackageTarballs_Call struct {
	*mock.Call
}

// AddToDownloadedPackageTarballs is a helper method to define mock.On call
//   - packageTarballName string
func (_e *ProjectMirror_Expecter) AddToDownloadedPackageTarballs(packageTarballName interface{}) *ProjectMirror_AddToDownloadedPackageTarballs_Call {
	return &ProjectMirror_AddToDownloadedPackageTarballs_Call{Call: _e.mock.On("AddToDownloadedPackageTarballs", packageTarballName)}
}

func (_c *ProjectMirror_AddToDownloadedPackageTarballs_Call) Run(run func(packageTarballName string)) *ProjectMirror_AddToDownloadedPackageTarballs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ProjectMirror_AddToDownloadedPackageTarballs_Call) Return() *ProjectMirror_AddToDownloadedPackageTarballs_Call {
	_c.Call.Return()
	return _c
}

func (_c *ProjectMirror_AddToDownloadedPackageTarballs_Call) RunAndReturn(run func(packageTarballName string)) *ProjectMirror_AddToDownloadedPackageTarballs_Call {
	_c.Run(run)
	return _c
}

// GetDownloadedPackageNames provides a mock function for the type ProjectMirror
func (_mock *ProjectMirror) GetDownloadedPackageNames() ([]string, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetDownloadedPackageNames")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() ([]string, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() []string); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProjectMirror_GetDownloadedPackageNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDownloadedPackageNames'
type ProjectMirror_GetDownloadedPackageNames_Call struct {
	*mock.Call
}

// GetDownloadedPackageNames is a helper method to define mock.On call
func (_e *ProjectMirror_Expecter) GetDownloadedPackageNames() *ProjectMirror_GetDownloadedPackageNames_Call {
	return &ProjectMirror_GetDownloadedPackageNames_Call{Call: _e.mock.On("GetDownloadedPackageNames")}
}

func (_c *ProjectMirror_GetDownloadedPackageNames_Call) Run(run func()) *ProjectMirror_GetDownloadedPackageNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ProjectMirror_GetDownloadedPackageNames_Call) Return(strings []string, err error) *ProjectMirror_GetDownloadedPackageNames_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *ProjectMirror_GetDownloadedPackageNames_Call) RunAndReturn(run func() ([]string, error)) *ProjectMirror_GetDownloadedPackageNames_Call {
	_c.Call.Return(run)
	return _c
}

// GetProjectName provides a mock function for the type ProjectMirror
func (_mock *ProjectMirror) GetProjectName() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetProjectName")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// ProjectMirror_GetProjectName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProjectName'
type ProjectMirror_GetProjectName_Call struct {
	*mock.Call
}

// GetProjectName is a helper method to define mock.On call
func (_e *ProjectMirror_Expecter) GetProjectName() *ProjectMirror_GetProjectName_Call {
	return &ProjectMirror_GetProjectName_Call{Call: _e.mock.On("GetProjectName")}
}

func (_c *ProjectMirror_GetProjectName_Call) Run(run func()) *ProjectMirror_GetProjectName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ProjectMirror_GetProjectName_Call) Return(s string) *ProjectMirror_GetProjectName_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *ProjectMirror_GetProjectName_Call) RunAndReturn(run func() string) *ProjectMirror_GetProjectName_Call {
	_c.Call.Return(run)
	return _c
}

// IsPackageTarballDownloaded provides a mock function for the type ProjectMirror
func (_mock *ProjectMirror) IsPackageTarballDownloaded(packageTarballName string) bool {
	ret := _mock.Called(packageTarballName)

	if len(ret) == 0 {
		panic("no return value specified for IsPackageTarballDownloaded")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(string) bool); ok {
		r0 = returnFunc(packageTarballName)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// ProjectMirror_IsPackageTarballDownloaded_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsPackageTarballDownloaded'
type ProjectMirror_IsPackageTarballDownloaded_Call struct {
	*mock.Call
}

// IsPackageTarballDownloaded is a helper method to define mock.On call
//   - packageTarballName string
func (_e *ProjectMirror_Expecter) IsPackageTarballDownloaded(packageTarballName interface{}) *ProjectMirror_IsPackageTarballDownloaded_Call {
	return &ProjectMirror_IsPackageTarballDownloaded_Call{Call: _e.mock.On("IsPackageTarballDownloaded", packageTarballName)}
}

func (_c *ProjectMirror_IsPackageTarballDownloaded_Call) Run(run func(packageTarballName string)) *ProjectMirror_IsPackageTarballDownloaded_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ProjectMirror_IsPackageTarballDownloaded_Call) Return(b bool) *ProjectMirror_IsPackageTarballDownloaded_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *ProjectMirror_IsPackageTarballDownloaded_Call) RunAndReturn(run func(packageTarballName string) bool) *ProjectMirror_IsPackageTarballDownloaded_Call {
	_c.Call.Return(run)
	return _c
}

// StartMirror provides a mock function for the type ProjectMirror
func (_mock *ProjectMirror) StartMirror(ctx context.Context, port int) error {
	ret := _mock.Called(ctx, port)

	if len(ret) == 0 {
		panic("no return value specified for StartMirror")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) error); ok {
		r0 = returnFunc(ctx, port)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ProjectMirror_StartMirror_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartMirror'
type ProjectMirror_StartMirror_Call struct {
	*mock.Call
}

// StartMirror is a helper method to define mock.On call
//   - ctx context.Context
//   - port int
func (_e *ProjectMirror_Expecter) StartMirror(ctx interface{}, port interface{}) *ProjectMirror_StartMirror_Call {
	return &ProjectMirror_StartMirror_Call{Call: _e.mock.On("StartMirror", ctx, port)}
}

func (_c *ProjectMirror_StartMirror_Call) Run(run func(ctx context.Context, port int)) *ProjectMirror_StartMirror_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ProjectMirror_StartMirror_Call) Return(err error) *ProjectMirror_StartMirror_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ProjectMirror_StartMirror_Call) RunAndReturn(run func(ctx context.Context, port int) error) *ProjectMirror_StartMirror_Call {
	_c.Call.Return(run)
	return _c
}

// NewIIssueTrackerService creates a new instance of IIssueTrackerService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIIssueTrackerService(t interface {
	mock.TestingT
	Cleanup(func())
}) *IIssueTrackerService {
	mock := &IIssueTrackerService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// IIssueTrackerService is an autogenerated mock type for the IIssueTrackerService type
type IIssueTrackerService struct {
	mock.Mock
}

type IIssueTrackerService_Expecter struct {
	mock *mock.Mock
}

func (_m *IIssueTrackerService) EXPECT() *IIssueTrackerService_Expecter {
	return &IIssueTrackerService_Expecter{mock: &_m.Mock}
}

// GetIssue provides a mock function for the type IIssueTrackerService
func (_mock *IIssueTrackerService) GetIssue(issueId int64) (*issuetracker.Issue, error) {
	ret := _mock.Called(issueId)

	if len(ret) == 0 {
		panic("no return value specified for GetIssue")
	}

	var r0 *issuetracker.Issue
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64) (*issuetracker.Issue, error)); ok {
		return returnFunc(issueId)
	}
	if returnFunc, ok := ret.Get(0).(func(int64) *issuetracker.Issue); ok {
		r0 = returnFunc(issueId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*issuetracker.Issue)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(int64) error); ok {
		r1 = returnFunc(issueId)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IIssueTrackerService_GetIssue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIssue'
type IIssueTrackerService_GetIssue_Call struct {
	*mock.Call
}

// GetIssue is a helper method to define mock.On call
//   - issueId int64
func (_e *IIssueTrackerService_Expecter) GetIssue(issueId interface{}) *IIssueTrackerService_GetIssue_Call {
	return &IIssueTrackerService_GetIssue_Call{Call: _e.mock.On("GetIssue", issueId)}
}

func (_c *IIssueTrackerService_GetIssue_Call) Run(run func(issueId int64)) *IIssueTrackerService_GetIssue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int64
		if args[0] != nil {
			arg0 = args[0].(int64)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *IIssueTrackerService_GetIssue_Call) Return(issue *issuetracker.Issue, err error) *IIssueTrackerService_GetIssue_Call {
	_c.Call.Return(issue, err)
	return _c
}

func (_c *IIssueTrackerService_GetIssue_Call) RunAndReturn(run func(issueId int64) (*issuetracker.Issue, error)) *IIssueTrackerService_GetIssue_Call {
	_c.Call.Return(run)
	return _c
}

// MakeIssue provides a mock function for the type IIssueTrackerService
func (_mock *IIssueTrackerService) MakeIssue(title string, body string, owner string) (*issuetracker.Issue, error) {
	ret := _mock.Called(title, body, owner)

	if len(ret) == 0 {
		panic("no return value specified for MakeIssue")
	}

	var r0 *issuetracker.Issue
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, string, string) (*issuetracker.Issue, error)); ok {
		return returnFunc(title, body, owner)
	}
	if returnFunc, ok := ret.Get(0).(func(string, string, string) *issuetracker.Issue); ok {
		r0 = returnFunc(title, body, owner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*issuetracker.Issue)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = returnFunc(title, body, owner)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IIssueTrackerService_MakeIssue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MakeIssue'
type IIssueTrackerService_MakeIssue_Call struct {
	*mock.Call
}

// MakeIssue is a helper method to define mock.On call
//   - title string
//   - body string
//   - owner string
func (_e *IIssueTrackerService_Expecter) MakeIssue(title interface{}, body interface{}, owner interface{}) *IIssueTrackerService_MakeIssue_Call {
	return &IIssueTrackerService_MakeIssue_Call{Call: _e.mock.On("MakeIssue", title, body, owner)}
}

func (_c *IIssueTrackerService_MakeIssue_Call) Run(run func(title string, body string, owner string)) *IIssueTrackerService_MakeIssue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *IIssueTrackerService_MakeIssue_Call) Return(issue *issuetracker.Issue, err error) *IIssueTrackerService_MakeIssue_Call {
	_c.Call.Return(issue, err)
	return _c
}

func (_c *IIssueTrackerService_MakeIssue_Call) RunAndReturn(run func(title string, body string, owner string) (*issuetracker.Issue, error)) *IIssueTrackerService_MakeIssue_Call {
	_c.Call.Return(run)
	return _c
}
