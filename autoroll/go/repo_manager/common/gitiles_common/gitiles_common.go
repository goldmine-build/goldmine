package gitiles_common

import (
	"context"
	"errors"
	"fmt"
	"net/http"

	"go.skia.org/infra/autoroll/go/config"
	"go.skia.org/infra/autoroll/go/config_vars"
	"go.skia.org/infra/autoroll/go/repo_manager/common/version_file_common"
	"go.skia.org/infra/autoroll/go/revision"
	"go.skia.org/infra/go/gitiles"
	"go.skia.org/infra/go/skerr"
	"go.skia.org/infra/go/vcsinfo"
	"go.skia.org/infra/go/vfs"
)

// GitilesConfig provides configuration for GitilesRepo.
type GitilesConfig struct {
	// Branch is the name of the git branch to be tracked by the GitilesRepo.
	Branch *config_vars.Template `json:"branch"`
	// RepoURL is the git repository URL.
	RepoURL string `json:"repoURL"`
	// Dependencies is an optional specification of dependencies to track.
	// Revisions generated by the GitilesRepo will contain the pinned versions
	// of these dependencies.
	Dependencies []*version_file_common.VersionFileConfig `json:"dependencies,omitempty"`
}

// Validate implements util.Validator.
func (c *GitilesConfig) Validate() error {
	if c.Branch == nil {
		return errors.New("Branch is required.")
	}
	if err := c.Branch.Validate(); err != nil {
		return skerr.Wrap(err)
	}
	if c.RepoURL == "" {
		return errors.New("RepoURL is required.")
	}
	return nil
}

// GitilesConfigToProto converts a GitilesConfig to a config.GitilesConfig.
func GitilesConfigToProto(cfg *GitilesConfig) *config.GitilesConfig {
	return &config.GitilesConfig{
		Branch:       cfg.Branch.RawTemplate(),
		RepoUrl:      cfg.RepoURL,
		Dependencies: version_file_common.VersionFileConfigsToProto(cfg.Dependencies),
	}
}

// ProtoToGitilesConfig converts a config.GitilesConfig to a GitilesConfig.
func ProtoToGitilesConfig(cfg *config.GitilesConfig) (*GitilesConfig, error) {
	branch, err := config_vars.NewTemplate(cfg.Branch)
	if err != nil {
		return nil, skerr.Wrap(err)
	}
	return &GitilesConfig{
		Branch:       branch,
		RepoURL:      cfg.RepoUrl,
		Dependencies: version_file_common.ProtoToVersionFileConfigs(cfg.Dependencies),
	}, nil
}

// GitilesRepo provides helpers for dealing with repos which use Gitiles.
type GitilesRepo struct {
	*gitiles.Repo
	branch *config_vars.Template
	deps   []*version_file_common.VersionFileConfig
}

// NewGitilesRepo returns a GitilesRepo instance.
func NewGitilesRepo(ctx context.Context, c GitilesConfig, reg *config_vars.Registry, client *http.Client) (*GitilesRepo, error) {
	if err := c.Validate(); err != nil {
		return nil, skerr.Wrap(err)
	}
	if err := reg.Register(c.Branch); err != nil {
		return nil, skerr.Wrap(err)
	}
	repo := gitiles.NewRepo(c.RepoURL, client)
	return &GitilesRepo{
		Repo:   repo,
		branch: c.Branch,
		deps:   c.Dependencies,
	}, nil
}

// Branch returns the resolved name of the branch tracked by this GitilesRepo.
func (r *GitilesRepo) Branch() string {
	return r.branch.String()
}

// GetRevision returns a revision.Revision instance associated with the given
// revision ID, which may be a commit hash or fully-qualified ref name.
func (r *GitilesRepo) GetRevision(ctx context.Context, id string) (*revision.Revision, error) {
	// Load the details for this revision.
	details, err := r.Details(ctx, id)
	if err != nil {
		return nil, skerr.Wrapf(err, "Failed to retrieve revision %q", id)
	}
	rev := revision.FromLongCommit(fmt.Sprintf(gitiles.CommitURL, r.URL, "%s"), details)

	// Optionally load any dependencies.
	if len(r.deps) > 0 {
		deps, err := version_file_common.GetPinnedRevs(ctx, r.deps, func(ctx context.Context, path string) (string, error) {
			return r.GetFile(ctx, path, rev.Id)
		})
		if err != nil {
			return nil, skerr.Wrap(err)
		}
		rev.Dependencies = deps
	}
	return rev, nil
}

// GetTipRevision returns a revision.Revision instance associated with the
// current tip of the branch tracked by this GitilesRepo.
func (r *GitilesRepo) GetTipRevision(ctx context.Context) (*revision.Revision, error) {
	return r.GetRevision(ctx, r.branch.String())
}

// ConvertRevisions converts the given slice of LongCommits to Revisions.
func (r *GitilesRepo) ConvertRevisions(ctx context.Context, commits []*vcsinfo.LongCommit) ([]*revision.Revision, error) {
	revs := make([]*revision.Revision, 0, len(commits))
	for _, commit := range commits {
		rev, err := r.GetRevision(ctx, commit.Hash)
		if err != nil {
			return nil, skerr.Wrapf(err, "Failed to retrieve revision")
		}
		revs = append(revs, rev)
	}
	return revs, nil
}

// GetFile retrieves the contents of the given file at the given ref.
func (r *GitilesRepo) GetFile(ctx context.Context, file, ref string) (string, error) {
	contents, err := r.ReadFileAtRef(ctx, file, ref)
	if err != nil {
		return "", skerr.Wrap(err)
	}
	return string(contents), nil
}

// VFS implements the child.Child interface.
func (r *GitilesRepo) VFS(ctx context.Context, rev *revision.Revision) (vfs.FS, error) {
	return r.Repo.VFS(ctx, rev.Id)
}
