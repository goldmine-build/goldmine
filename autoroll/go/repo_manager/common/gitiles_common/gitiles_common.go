package gitiles_common

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strings"

	"go.skia.org/infra/autoroll/go/config_vars"
	"go.skia.org/infra/autoroll/go/revision"
	"go.skia.org/infra/go/depot_tools/deps_parser"
	"go.skia.org/infra/go/gitiles"
	"go.skia.org/infra/go/skerr"
)

// GitilesConfig provides configuration for GitilesRepo.
type GitilesConfig struct {
	// Branch is the name of the git branch to be rolled.
	Branch *config_vars.Template `json:"branch"`
	// RepoURL is the git repository URL.
	RepoURL string `json:"repoURL"`
	// Dependencies is an optional mapping of dependency ID (eg. repo URL)
	// to the location within the repo where its version is pinned (eg. DEPS).
	// Revisions generated by the GitilesRepo will contain the versions of
	// these dependencies. The values must be either files whose entire
	// contents are the version ID of the dependency, or "DEPS" which is a
	// special case.
	Dependencies map[string]string `json:"dependencies,omitempty"`
}

// See documentation for util.Validator interface.
func (c *GitilesConfig) Validate() error {
	if c.Branch == nil {
		return errors.New("Branch is required.")
	}
	if err := c.Branch.Validate(); err != nil {
		return skerr.Wrap(err)
	}
	if c.RepoURL == "" {
		return errors.New("RepoURL is required.")
	}
	return nil
}

// GitilesRepo provides helpers for dealing with repos which use Gitiles.
type GitilesRepo struct {
	*gitiles.Repo
	branch *config_vars.Template
	deps   map[string]string
}

// NewGitilesRepo returns a GitilesRepo instance.
func NewGitilesRepo(ctx context.Context, c GitilesConfig, reg *config_vars.Registry, client *http.Client) (*GitilesRepo, error) {
	if err := c.Validate(); err != nil {
		return nil, skerr.Wrap(err)
	}
	if err := reg.Register(c.Branch); err != nil {
		return nil, skerr.Wrap(err)
	}
	repo := gitiles.NewRepo(c.RepoURL, client)
	return &GitilesRepo{
		Repo:   repo,
		branch: c.Branch,
		deps:   c.Dependencies,
	}, nil
}

// Branch returns the resolved name of the branch tracked by this GitilesRepo.
func (r *GitilesRepo) Branch() string {
	return r.branch.String()
}

// GetRevision returns a revision.Revision instance associated with the given
// revision ID, which may be a commit hash or fully-qualified ref name.
func (r *GitilesRepo) GetRevision(ctx context.Context, id string) (*revision.Revision, error) {
	// Load the details for this revision.
	details, err := r.Details(ctx, id)
	if err != nil {
		return nil, skerr.Wrapf(err, "Failed to retrieve revision %q", id)
	}
	rev := revision.FromLongCommit(fmt.Sprintf(gitiles.COMMIT_URL, r.URL, "%s"), details)

	// Optionally load any dependencies.
	if len(r.deps) > 0 {
		rev.Dependencies = make(map[string]string, len(r.deps))
		var depsEntries deps_parser.DepsEntries
		for dep, path := range r.deps {
			if path == deps_parser.DepsFileName {
				// Lazily load the DEPS entries.
				if depsEntries == nil {
					var err error
					depsEntries, err = r.ParseDEPS(ctx, rev.Id)
					if err != nil {
						return nil, skerr.Wrap(err)
					}
				}

				// Find the desired DEPS entry.
				entry := depsEntries.Get(dep)
				if entry == nil {
					b, err := json.MarshalIndent(depsEntries, "", "  ")
					if err == nil {
						return nil, skerr.Fmt("Dependency %q not found in DEPS:\n%s", dep, string(b))
					} else {
						return nil, skerr.Fmt("Dependency %q not found in DEPS; failed to marshal JSON: %s", dep, err)
					}
				}
				rev.Dependencies[dep] = entry.Version
			} else {
				var buf bytes.Buffer
				if err := r.ReadFileAtRef(ctx, path, id, &buf); err != nil {
					return nil, skerr.Wrap(err)
				}
				rev.Dependencies[dep] = strings.TrimSpace(buf.String())
			}
		}
	}
	return rev, nil
}

// GetTipRevision returns a revision.Revision instance associated with the
// current tip of the branch tracked by this GitilesRepo.
func (r *GitilesRepo) GetTipRevision(ctx context.Context) (*revision.Revision, error) {
	return r.GetRevision(ctx, r.branch.String())
}

// LogLinear returns a slice of revision.Revision instances in the given range.
func (r *GitilesRepo) LogLinear(ctx context.Context, from, to *revision.Revision) ([]*revision.Revision, error) {
	commits, err := r.Repo.LogLinear(ctx, from.Id, to.Id)
	if err != nil {
		return nil, err
	}
	revs := make([]*revision.Revision, 0, len(commits))
	for _, commit := range commits {
		rev, err := r.GetRevision(ctx, commit.Hash)
		if err != nil {
			return nil, skerr.Wrapf(err, "Failed to retrieve revision")
		}
		revs = append(revs, rev)
	}
	return revs, nil
}

// ParseDEPS retrieves the DEPS file at the given ref and returns the parsed
// entries.
func (r *GitilesRepo) ParseDEPS(ctx context.Context, ref string) (deps_parser.DepsEntries, error) {
	var buf bytes.Buffer
	if err := r.ReadFileAtRef(ctx, deps_parser.DepsFileName, ref, &buf); err != nil {
		return nil, skerr.Wrap(err)
	}
	return deps_parser.ParseDeps(buf.String())
}
