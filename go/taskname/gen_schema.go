// +build ignore

package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"runtime"
	"sort"
	"strings"

	"go.skia.org/infra/go/exec"
	"go.skia.org/infra/go/gitiles"
	"go.skia.org/infra/go/sklog"
)

const (
	TARGET_FILE = "task_name_schema_gen.go"
	TMPL        = `// Code generated by "go run gen_schema.go"; DO NOT EDIT

package taskname

var SCHEMA_FROM_GIT = map[string][]string{
%s}

var SEPARATOR_FROM_GIT = "%s"
`
)

type taskNameSchema struct {
	// Schema maps a config (e.g. Build) to the ordered list of keys in the name
	// Note, the json names are a carryover from Buildbot days, where builder == task
	Schema map[string][]string `json:"builder_name_schema"`
	// TaskNameSep specifies how the various keys will be seperated, e.g. "-"
	TaskNameSep string `json:"builder_name_sep"`
}

func main() {
	_, filename, _, _ := runtime.Caller(0)
	pkgDir := path.Dir(filename)

	// Load the schema from JSON
	buf := bytes.NewBuffer(nil)
	r := gitiles.NewRepo("https://skia.googlesource.com/skia")
	if err := r.ReadFile("infra/bots/recipe_modules/builder_name_schema/builder_name_schema.json", buf); err != nil {
		sklog.Fatalf("Could not read schema file: %s\n", err)
	}
	schema := new(taskNameSchema)
	if err := json.NewDecoder(buf).Decode(schema); err != nil {
		sklog.Fatalf("Could not decode schema file: %s\n", err)
	}

	schemaLines := []string{}
	for key, value := range schema.Schema {
		line := fmt.Sprintf("\t\"%s\": %#v,\n", key, value)
		schemaLines = append(schemaLines, line)
	}
	sort.Strings(schemaLines)
	assetsStr := strings.Join(schemaLines, "")
	fileContents := []byte(fmt.Sprintf(TMPL, assetsStr, schema.TaskNameSep))
	targetFile := path.Join(pkgDir, TARGET_FILE)
	if err := ioutil.WriteFile(targetFile, fileContents, os.ModePerm); err != nil {
		sklog.Fatal(err)
	}
	if _, err := exec.RunCwd(context.Background(), ".", "gofmt", "-s", "-w", targetFile); err != nil {
		sklog.Fatal(err)
	}
}
