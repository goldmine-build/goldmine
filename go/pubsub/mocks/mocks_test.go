// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"time"

	"cloud.google.com/go/iam"
	"cloud.google.com/go/pubsub"
	mock "github.com/stretchr/testify/mock"
	pubsub0 "go.skia.org/infra/go/pubsub"
)

// NewClient creates a new instance of Client. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *Client {
	mock := &Client{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

type Client_Expecter struct {
	mock *mock.Mock
}

func (_m *Client) EXPECT() *Client_Expecter {
	return &Client_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type Client
func (_mock *Client) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Client_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type Client_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *Client_Expecter) Close() *Client_Close_Call {
	return &Client_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *Client_Close_Call) Run(run func()) *Client_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Client_Close_Call) Return(err error) *Client_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Client_Close_Call) RunAndReturn(run func() error) *Client_Close_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSubscription provides a mock function for the type Client
func (_mock *Client) CreateSubscription(ctx context.Context, id string, cfg pubsub.SubscriptionConfig) (pubsub0.Subscription, error) {
	ret := _mock.Called(ctx, id, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateSubscription")
	}

	var r0 pubsub0.Subscription
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, pubsub.SubscriptionConfig) (pubsub0.Subscription, error)); ok {
		return returnFunc(ctx, id, cfg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, pubsub.SubscriptionConfig) pubsub0.Subscription); ok {
		r0 = returnFunc(ctx, id, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pubsub0.Subscription)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, pubsub.SubscriptionConfig) error); ok {
		r1 = returnFunc(ctx, id, cfg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_CreateSubscription_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSubscription'
type Client_CreateSubscription_Call struct {
	*mock.Call
}

// CreateSubscription is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - cfg pubsub.SubscriptionConfig
func (_e *Client_Expecter) CreateSubscription(ctx interface{}, id interface{}, cfg interface{}) *Client_CreateSubscription_Call {
	return &Client_CreateSubscription_Call{Call: _e.mock.On("CreateSubscription", ctx, id, cfg)}
}

func (_c *Client_CreateSubscription_Call) Run(run func(ctx context.Context, id string, cfg pubsub.SubscriptionConfig)) *Client_CreateSubscription_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 pubsub.SubscriptionConfig
		if args[2] != nil {
			arg2 = args[2].(pubsub.SubscriptionConfig)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Client_CreateSubscription_Call) Return(subscription pubsub0.Subscription, err error) *Client_CreateSubscription_Call {
	_c.Call.Return(subscription, err)
	return _c
}

func (_c *Client_CreateSubscription_Call) RunAndReturn(run func(ctx context.Context, id string, cfg pubsub.SubscriptionConfig) (pubsub0.Subscription, error)) *Client_CreateSubscription_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTopic provides a mock function for the type Client
func (_mock *Client) CreateTopic(ctx context.Context, topicID string) (pubsub0.Topic, error) {
	ret := _mock.Called(ctx, topicID)

	if len(ret) == 0 {
		panic("no return value specified for CreateTopic")
	}

	var r0 pubsub0.Topic
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (pubsub0.Topic, error)); ok {
		return returnFunc(ctx, topicID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) pubsub0.Topic); ok {
		r0 = returnFunc(ctx, topicID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pubsub0.Topic)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, topicID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_CreateTopic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTopic'
type Client_CreateTopic_Call struct {
	*mock.Call
}

// CreateTopic is a helper method to define mock.On call
//   - ctx context.Context
//   - topicID string
func (_e *Client_Expecter) CreateTopic(ctx interface{}, topicID interface{}) *Client_CreateTopic_Call {
	return &Client_CreateTopic_Call{Call: _e.mock.On("CreateTopic", ctx, topicID)}
}

func (_c *Client_CreateTopic_Call) Run(run func(ctx context.Context, topicID string)) *Client_CreateTopic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_CreateTopic_Call) Return(topic pubsub0.Topic, err error) *Client_CreateTopic_Call {
	_c.Call.Return(topic, err)
	return _c
}

func (_c *Client_CreateTopic_Call) RunAndReturn(run func(ctx context.Context, topicID string) (pubsub0.Topic, error)) *Client_CreateTopic_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTopicWithConfig provides a mock function for the type Client
func (_mock *Client) CreateTopicWithConfig(ctx context.Context, topicID string, tc *pubsub.TopicConfig) (pubsub0.Topic, error) {
	ret := _mock.Called(ctx, topicID, tc)

	if len(ret) == 0 {
		panic("no return value specified for CreateTopicWithConfig")
	}

	var r0 pubsub0.Topic
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *pubsub.TopicConfig) (pubsub0.Topic, error)); ok {
		return returnFunc(ctx, topicID, tc)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *pubsub.TopicConfig) pubsub0.Topic); ok {
		r0 = returnFunc(ctx, topicID, tc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pubsub0.Topic)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, *pubsub.TopicConfig) error); ok {
		r1 = returnFunc(ctx, topicID, tc)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_CreateTopicWithConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTopicWithConfig'
type Client_CreateTopicWithConfig_Call struct {
	*mock.Call
}

// CreateTopicWithConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - topicID string
//   - tc *pubsub.TopicConfig
func (_e *Client_Expecter) CreateTopicWithConfig(ctx interface{}, topicID interface{}, tc interface{}) *Client_CreateTopicWithConfig_Call {
	return &Client_CreateTopicWithConfig_Call{Call: _e.mock.On("CreateTopicWithConfig", ctx, topicID, tc)}
}

func (_c *Client_CreateTopicWithConfig_Call) Run(run func(ctx context.Context, topicID string, tc *pubsub.TopicConfig)) *Client_CreateTopicWithConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *pubsub.TopicConfig
		if args[2] != nil {
			arg2 = args[2].(*pubsub.TopicConfig)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *Client_CreateTopicWithConfig_Call) Return(topic pubsub0.Topic, err error) *Client_CreateTopicWithConfig_Call {
	_c.Call.Return(topic, err)
	return _c
}

func (_c *Client_CreateTopicWithConfig_Call) RunAndReturn(run func(ctx context.Context, topicID string, tc *pubsub.TopicConfig) (pubsub0.Topic, error)) *Client_CreateTopicWithConfig_Call {
	_c.Call.Return(run)
	return _c
}

// DetachSubscription provides a mock function for the type Client
func (_mock *Client) DetachSubscription(ctx context.Context, sub string) (*pubsub.DetachSubscriptionResult, error) {
	ret := _mock.Called(ctx, sub)

	if len(ret) == 0 {
		panic("no return value specified for DetachSubscription")
	}

	var r0 *pubsub.DetachSubscriptionResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*pubsub.DetachSubscriptionResult, error)); ok {
		return returnFunc(ctx, sub)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *pubsub.DetachSubscriptionResult); ok {
		r0 = returnFunc(ctx, sub)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pubsub.DetachSubscriptionResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, sub)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Client_DetachSubscription_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DetachSubscription'
type Client_DetachSubscription_Call struct {
	*mock.Call
}

// DetachSubscription is a helper method to define mock.On call
//   - ctx context.Context
//   - sub string
func (_e *Client_Expecter) DetachSubscription(ctx interface{}, sub interface{}) *Client_DetachSubscription_Call {
	return &Client_DetachSubscription_Call{Call: _e.mock.On("DetachSubscription", ctx, sub)}
}

func (_c *Client_DetachSubscription_Call) Run(run func(ctx context.Context, sub string)) *Client_DetachSubscription_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_DetachSubscription_Call) Return(detachSubscriptionResult *pubsub.DetachSubscriptionResult, err error) *Client_DetachSubscription_Call {
	_c.Call.Return(detachSubscriptionResult, err)
	return _c
}

func (_c *Client_DetachSubscription_Call) RunAndReturn(run func(ctx context.Context, sub string) (*pubsub.DetachSubscriptionResult, error)) *Client_DetachSubscription_Call {
	_c.Call.Return(run)
	return _c
}

// Project provides a mock function for the type Client
func (_mock *Client) Project() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Project")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// Client_Project_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Project'
type Client_Project_Call struct {
	*mock.Call
}

// Project is a helper method to define mock.On call
func (_e *Client_Expecter) Project() *Client_Project_Call {
	return &Client_Project_Call{Call: _e.mock.On("Project")}
}

func (_c *Client_Project_Call) Run(run func()) *Client_Project_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Client_Project_Call) Return(s string) *Client_Project_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *Client_Project_Call) RunAndReturn(run func() string) *Client_Project_Call {
	_c.Call.Return(run)
	return _c
}

// Snapshot provides a mock function for the type Client
func (_mock *Client) Snapshot(id string) pubsub0.Snapshot {
	ret := _mock.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for Snapshot")
	}

	var r0 pubsub0.Snapshot
	if returnFunc, ok := ret.Get(0).(func(string) pubsub0.Snapshot); ok {
		r0 = returnFunc(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pubsub0.Snapshot)
		}
	}
	return r0
}

// Client_Snapshot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Snapshot'
type Client_Snapshot_Call struct {
	*mock.Call
}

// Snapshot is a helper method to define mock.On call
//   - id string
func (_e *Client_Expecter) Snapshot(id interface{}) *Client_Snapshot_Call {
	return &Client_Snapshot_Call{Call: _e.mock.On("Snapshot", id)}
}

func (_c *Client_Snapshot_Call) Run(run func(id string)) *Client_Snapshot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_Snapshot_Call) Return(snapshot pubsub0.Snapshot) *Client_Snapshot_Call {
	_c.Call.Return(snapshot)
	return _c
}

func (_c *Client_Snapshot_Call) RunAndReturn(run func(id string) pubsub0.Snapshot) *Client_Snapshot_Call {
	_c.Call.Return(run)
	return _c
}

// Snapshots provides a mock function for the type Client
func (_mock *Client) Snapshots(ctx context.Context) *pubsub.SnapshotConfigIterator {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Snapshots")
	}

	var r0 *pubsub.SnapshotConfigIterator
	if returnFunc, ok := ret.Get(0).(func(context.Context) *pubsub.SnapshotConfigIterator); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pubsub.SnapshotConfigIterator)
		}
	}
	return r0
}

// Client_Snapshots_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Snapshots'
type Client_Snapshots_Call struct {
	*mock.Call
}

// Snapshots is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) Snapshots(ctx interface{}) *Client_Snapshots_Call {
	return &Client_Snapshots_Call{Call: _e.mock.On("Snapshots", ctx)}
}

func (_c *Client_Snapshots_Call) Run(run func(ctx context.Context)) *Client_Snapshots_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_Snapshots_Call) Return(snapshotConfigIterator *pubsub.SnapshotConfigIterator) *Client_Snapshots_Call {
	_c.Call.Return(snapshotConfigIterator)
	return _c
}

func (_c *Client_Snapshots_Call) RunAndReturn(run func(ctx context.Context) *pubsub.SnapshotConfigIterator) *Client_Snapshots_Call {
	_c.Call.Return(run)
	return _c
}

// Subscription provides a mock function for the type Client
func (_mock *Client) Subscription(id string) pubsub0.Subscription {
	ret := _mock.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for Subscription")
	}

	var r0 pubsub0.Subscription
	if returnFunc, ok := ret.Get(0).(func(string) pubsub0.Subscription); ok {
		r0 = returnFunc(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pubsub0.Subscription)
		}
	}
	return r0
}

// Client_Subscription_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscription'
type Client_Subscription_Call struct {
	*mock.Call
}

// Subscription is a helper method to define mock.On call
//   - id string
func (_e *Client_Expecter) Subscription(id interface{}) *Client_Subscription_Call {
	return &Client_Subscription_Call{Call: _e.mock.On("Subscription", id)}
}

func (_c *Client_Subscription_Call) Run(run func(id string)) *Client_Subscription_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_Subscription_Call) Return(subscription pubsub0.Subscription) *Client_Subscription_Call {
	_c.Call.Return(subscription)
	return _c
}

func (_c *Client_Subscription_Call) RunAndReturn(run func(id string) pubsub0.Subscription) *Client_Subscription_Call {
	_c.Call.Return(run)
	return _c
}

// SubscriptionInProject provides a mock function for the type Client
func (_mock *Client) SubscriptionInProject(id string, projectID string) pubsub0.Subscription {
	ret := _mock.Called(id, projectID)

	if len(ret) == 0 {
		panic("no return value specified for SubscriptionInProject")
	}

	var r0 pubsub0.Subscription
	if returnFunc, ok := ret.Get(0).(func(string, string) pubsub0.Subscription); ok {
		r0 = returnFunc(id, projectID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pubsub0.Subscription)
		}
	}
	return r0
}

// Client_SubscriptionInProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscriptionInProject'
type Client_SubscriptionInProject_Call struct {
	*mock.Call
}

// SubscriptionInProject is a helper method to define mock.On call
//   - id string
//   - projectID string
func (_e *Client_Expecter) SubscriptionInProject(id interface{}, projectID interface{}) *Client_SubscriptionInProject_Call {
	return &Client_SubscriptionInProject_Call{Call: _e.mock.On("SubscriptionInProject", id, projectID)}
}

func (_c *Client_SubscriptionInProject_Call) Run(run func(id string, projectID string)) *Client_SubscriptionInProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_SubscriptionInProject_Call) Return(subscription pubsub0.Subscription) *Client_SubscriptionInProject_Call {
	_c.Call.Return(subscription)
	return _c
}

func (_c *Client_SubscriptionInProject_Call) RunAndReturn(run func(id string, projectID string) pubsub0.Subscription) *Client_SubscriptionInProject_Call {
	_c.Call.Return(run)
	return _c
}

// Subscriptions provides a mock function for the type Client
func (_mock *Client) Subscriptions(ctx context.Context) *pubsub.SubscriptionIterator {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Subscriptions")
	}

	var r0 *pubsub.SubscriptionIterator
	if returnFunc, ok := ret.Get(0).(func(context.Context) *pubsub.SubscriptionIterator); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pubsub.SubscriptionIterator)
		}
	}
	return r0
}

// Client_Subscriptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscriptions'
type Client_Subscriptions_Call struct {
	*mock.Call
}

// Subscriptions is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) Subscriptions(ctx interface{}) *Client_Subscriptions_Call {
	return &Client_Subscriptions_Call{Call: _e.mock.On("Subscriptions", ctx)}
}

func (_c *Client_Subscriptions_Call) Run(run func(ctx context.Context)) *Client_Subscriptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_Subscriptions_Call) Return(subscriptionIterator *pubsub.SubscriptionIterator) *Client_Subscriptions_Call {
	_c.Call.Return(subscriptionIterator)
	return _c
}

func (_c *Client_Subscriptions_Call) RunAndReturn(run func(ctx context.Context) *pubsub.SubscriptionIterator) *Client_Subscriptions_Call {
	_c.Call.Return(run)
	return _c
}

// Topic provides a mock function for the type Client
func (_mock *Client) Topic(id string) pubsub0.Topic {
	ret := _mock.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for Topic")
	}

	var r0 pubsub0.Topic
	if returnFunc, ok := ret.Get(0).(func(string) pubsub0.Topic); ok {
		r0 = returnFunc(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pubsub0.Topic)
		}
	}
	return r0
}

// Client_Topic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Topic'
type Client_Topic_Call struct {
	*mock.Call
}

// Topic is a helper method to define mock.On call
//   - id string
func (_e *Client_Expecter) Topic(id interface{}) *Client_Topic_Call {
	return &Client_Topic_Call{Call: _e.mock.On("Topic", id)}
}

func (_c *Client_Topic_Call) Run(run func(id string)) *Client_Topic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_Topic_Call) Return(topic pubsub0.Topic) *Client_Topic_Call {
	_c.Call.Return(topic)
	return _c
}

func (_c *Client_Topic_Call) RunAndReturn(run func(id string) pubsub0.Topic) *Client_Topic_Call {
	_c.Call.Return(run)
	return _c
}

// TopicInProject provides a mock function for the type Client
func (_mock *Client) TopicInProject(id string, projectID string) pubsub0.Topic {
	ret := _mock.Called(id, projectID)

	if len(ret) == 0 {
		panic("no return value specified for TopicInProject")
	}

	var r0 pubsub0.Topic
	if returnFunc, ok := ret.Get(0).(func(string, string) pubsub0.Topic); ok {
		r0 = returnFunc(id, projectID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pubsub0.Topic)
		}
	}
	return r0
}

// Client_TopicInProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TopicInProject'
type Client_TopicInProject_Call struct {
	*mock.Call
}

// TopicInProject is a helper method to define mock.On call
//   - id string
//   - projectID string
func (_e *Client_Expecter) TopicInProject(id interface{}, projectID interface{}) *Client_TopicInProject_Call {
	return &Client_TopicInProject_Call{Call: _e.mock.On("TopicInProject", id, projectID)}
}

func (_c *Client_TopicInProject_Call) Run(run func(id string, projectID string)) *Client_TopicInProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Client_TopicInProject_Call) Return(topic pubsub0.Topic) *Client_TopicInProject_Call {
	_c.Call.Return(topic)
	return _c
}

func (_c *Client_TopicInProject_Call) RunAndReturn(run func(id string, projectID string) pubsub0.Topic) *Client_TopicInProject_Call {
	_c.Call.Return(run)
	return _c
}

// Topics provides a mock function for the type Client
func (_mock *Client) Topics(ctx context.Context) *pubsub.TopicIterator {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Topics")
	}

	var r0 *pubsub.TopicIterator
	if returnFunc, ok := ret.Get(0).(func(context.Context) *pubsub.TopicIterator); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pubsub.TopicIterator)
		}
	}
	return r0
}

// Client_Topics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Topics'
type Client_Topics_Call struct {
	*mock.Call
}

// Topics is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Client_Expecter) Topics(ctx interface{}) *Client_Topics_Call {
	return &Client_Topics_Call{Call: _e.mock.On("Topics", ctx)}
}

func (_c *Client_Topics_Call) Run(run func(ctx context.Context)) *Client_Topics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Client_Topics_Call) Return(topicIterator *pubsub.TopicIterator) *Client_Topics_Call {
	_c.Call.Return(topicIterator)
	return _c
}

func (_c *Client_Topics_Call) RunAndReturn(run func(ctx context.Context) *pubsub.TopicIterator) *Client_Topics_Call {
	_c.Call.Return(run)
	return _c
}

// NewSnapshot creates a new instance of Snapshot. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSnapshot(t interface {
	mock.TestingT
	Cleanup(func())
}) *Snapshot {
	mock := &Snapshot{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Snapshot is an autogenerated mock type for the Snapshot type
type Snapshot struct {
	mock.Mock
}

type Snapshot_Expecter struct {
	mock *mock.Mock
}

func (_m *Snapshot) EXPECT() *Snapshot_Expecter {
	return &Snapshot_Expecter{mock: &_m.Mock}
}

// Delete provides a mock function for the type Snapshot
func (_mock *Snapshot) Delete(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Snapshot_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type Snapshot_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Snapshot_Expecter) Delete(ctx interface{}) *Snapshot_Delete_Call {
	return &Snapshot_Delete_Call{Call: _e.mock.On("Delete", ctx)}
}

func (_c *Snapshot_Delete_Call) Run(run func(ctx context.Context)) *Snapshot_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Snapshot_Delete_Call) Return(err error) *Snapshot_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Snapshot_Delete_Call) RunAndReturn(run func(ctx context.Context) error) *Snapshot_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// ID provides a mock function for the type Snapshot
func (_mock *Snapshot) ID() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ID")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// Snapshot_ID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ID'
type Snapshot_ID_Call struct {
	*mock.Call
}

// ID is a helper method to define mock.On call
func (_e *Snapshot_Expecter) ID() *Snapshot_ID_Call {
	return &Snapshot_ID_Call{Call: _e.mock.On("ID")}
}

func (_c *Snapshot_ID_Call) Run(run func()) *Snapshot_ID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Snapshot_ID_Call) Return(s string) *Snapshot_ID_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *Snapshot_ID_Call) RunAndReturn(run func() string) *Snapshot_ID_Call {
	_c.Call.Return(run)
	return _c
}

// SetLabels provides a mock function for the type Snapshot
func (_mock *Snapshot) SetLabels(ctx context.Context, label map[string]string) (*pubsub.SnapshotConfig, error) {
	ret := _mock.Called(ctx, label)

	if len(ret) == 0 {
		panic("no return value specified for SetLabels")
	}

	var r0 *pubsub.SnapshotConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, map[string]string) (*pubsub.SnapshotConfig, error)); ok {
		return returnFunc(ctx, label)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, map[string]string) *pubsub.SnapshotConfig); ok {
		r0 = returnFunc(ctx, label)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pubsub.SnapshotConfig)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, map[string]string) error); ok {
		r1 = returnFunc(ctx, label)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Snapshot_SetLabels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetLabels'
type Snapshot_SetLabels_Call struct {
	*mock.Call
}

// SetLabels is a helper method to define mock.On call
//   - ctx context.Context
//   - label map[string]string
func (_e *Snapshot_Expecter) SetLabels(ctx interface{}, label interface{}) *Snapshot_SetLabels_Call {
	return &Snapshot_SetLabels_Call{Call: _e.mock.On("SetLabels", ctx, label)}
}

func (_c *Snapshot_SetLabels_Call) Run(run func(ctx context.Context, label map[string]string)) *Snapshot_SetLabels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 map[string]string
		if args[1] != nil {
			arg1 = args[1].(map[string]string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Snapshot_SetLabels_Call) Return(snapshotConfig *pubsub.SnapshotConfig, err error) *Snapshot_SetLabels_Call {
	_c.Call.Return(snapshotConfig, err)
	return _c
}

func (_c *Snapshot_SetLabels_Call) RunAndReturn(run func(ctx context.Context, label map[string]string) (*pubsub.SnapshotConfig, error)) *Snapshot_SetLabels_Call {
	_c.Call.Return(run)
	return _c
}

// NewSubscription creates a new instance of Subscription. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSubscription(t interface {
	mock.TestingT
	Cleanup(func())
}) *Subscription {
	mock := &Subscription{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Subscription is an autogenerated mock type for the Subscription type
type Subscription struct {
	mock.Mock
}

type Subscription_Expecter struct {
	mock *mock.Mock
}

func (_m *Subscription) EXPECT() *Subscription_Expecter {
	return &Subscription_Expecter{mock: &_m.Mock}
}

// Config provides a mock function for the type Subscription
func (_mock *Subscription) Config(ctx context.Context) (pubsub.SubscriptionConfig, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Config")
	}

	var r0 pubsub.SubscriptionConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (pubsub.SubscriptionConfig, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) pubsub.SubscriptionConfig); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(pubsub.SubscriptionConfig)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Subscription_Config_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Config'
type Subscription_Config_Call struct {
	*mock.Call
}

// Config is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Subscription_Expecter) Config(ctx interface{}) *Subscription_Config_Call {
	return &Subscription_Config_Call{Call: _e.mock.On("Config", ctx)}
}

func (_c *Subscription_Config_Call) Run(run func(ctx context.Context)) *Subscription_Config_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Subscription_Config_Call) Return(subscriptionConfig pubsub.SubscriptionConfig, err error) *Subscription_Config_Call {
	_c.Call.Return(subscriptionConfig, err)
	return _c
}

func (_c *Subscription_Config_Call) RunAndReturn(run func(ctx context.Context) (pubsub.SubscriptionConfig, error)) *Subscription_Config_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSnapshot provides a mock function for the type Subscription
func (_mock *Subscription) CreateSnapshot(ctx context.Context, name string) (*pubsub.SnapshotConfig, error) {
	ret := _mock.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for CreateSnapshot")
	}

	var r0 *pubsub.SnapshotConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*pubsub.SnapshotConfig, error)); ok {
		return returnFunc(ctx, name)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *pubsub.SnapshotConfig); ok {
		r0 = returnFunc(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pubsub.SnapshotConfig)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, name)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Subscription_CreateSnapshot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSnapshot'
type Subscription_CreateSnapshot_Call struct {
	*mock.Call
}

// CreateSnapshot is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Subscription_Expecter) CreateSnapshot(ctx interface{}, name interface{}) *Subscription_CreateSnapshot_Call {
	return &Subscription_CreateSnapshot_Call{Call: _e.mock.On("CreateSnapshot", ctx, name)}
}

func (_c *Subscription_CreateSnapshot_Call) Run(run func(ctx context.Context, name string)) *Subscription_CreateSnapshot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Subscription_CreateSnapshot_Call) Return(snapshotConfig *pubsub.SnapshotConfig, err error) *Subscription_CreateSnapshot_Call {
	_c.Call.Return(snapshotConfig, err)
	return _c
}

func (_c *Subscription_CreateSnapshot_Call) RunAndReturn(run func(ctx context.Context, name string) (*pubsub.SnapshotConfig, error)) *Subscription_CreateSnapshot_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type Subscription
func (_mock *Subscription) Delete(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Subscription_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type Subscription_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Subscription_Expecter) Delete(ctx interface{}) *Subscription_Delete_Call {
	return &Subscription_Delete_Call{Call: _e.mock.On("Delete", ctx)}
}

func (_c *Subscription_Delete_Call) Run(run func(ctx context.Context)) *Subscription_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Subscription_Delete_Call) Return(err error) *Subscription_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Subscription_Delete_Call) RunAndReturn(run func(ctx context.Context) error) *Subscription_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type Subscription
func (_mock *Subscription) Exists(ctx context.Context) (bool, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (bool, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) bool); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Subscription_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type Subscription_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Subscription_Expecter) Exists(ctx interface{}) *Subscription_Exists_Call {
	return &Subscription_Exists_Call{Call: _e.mock.On("Exists", ctx)}
}

func (_c *Subscription_Exists_Call) Run(run func(ctx context.Context)) *Subscription_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Subscription_Exists_Call) Return(b bool, err error) *Subscription_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *Subscription_Exists_Call) RunAndReturn(run func(ctx context.Context) (bool, error)) *Subscription_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// IAM provides a mock function for the type Subscription
func (_mock *Subscription) IAM() *iam.Handle {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for IAM")
	}

	var r0 *iam.Handle
	if returnFunc, ok := ret.Get(0).(func() *iam.Handle); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.Handle)
		}
	}
	return r0
}

// Subscription_IAM_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IAM'
type Subscription_IAM_Call struct {
	*mock.Call
}

// IAM is a helper method to define mock.On call
func (_e *Subscription_Expecter) IAM() *Subscription_IAM_Call {
	return &Subscription_IAM_Call{Call: _e.mock.On("IAM")}
}

func (_c *Subscription_IAM_Call) Run(run func()) *Subscription_IAM_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Subscription_IAM_Call) Return(handle *iam.Handle) *Subscription_IAM_Call {
	_c.Call.Return(handle)
	return _c
}

func (_c *Subscription_IAM_Call) RunAndReturn(run func() *iam.Handle) *Subscription_IAM_Call {
	_c.Call.Return(run)
	return _c
}

// ID provides a mock function for the type Subscription
func (_mock *Subscription) ID() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ID")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// Subscription_ID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ID'
type Subscription_ID_Call struct {
	*mock.Call
}

// ID is a helper method to define mock.On call
func (_e *Subscription_Expecter) ID() *Subscription_ID_Call {
	return &Subscription_ID_Call{Call: _e.mock.On("ID")}
}

func (_c *Subscription_ID_Call) Run(run func()) *Subscription_ID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Subscription_ID_Call) Return(s string) *Subscription_ID_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *Subscription_ID_Call) RunAndReturn(run func() string) *Subscription_ID_Call {
	_c.Call.Return(run)
	return _c
}

// Receive provides a mock function for the type Subscription
func (_mock *Subscription) Receive(ctx context.Context, f func(context.Context, *pubsub.Message)) error {
	ret := _mock.Called(ctx, f)

	if len(ret) == 0 {
		panic("no return value specified for Receive")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, func(context.Context, *pubsub.Message)) error); ok {
		r0 = returnFunc(ctx, f)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Subscription_Receive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Receive'
type Subscription_Receive_Call struct {
	*mock.Call
}

// Receive is a helper method to define mock.On call
//   - ctx context.Context
//   - f func(context.Context, *pubsub.Message)
func (_e *Subscription_Expecter) Receive(ctx interface{}, f interface{}) *Subscription_Receive_Call {
	return &Subscription_Receive_Call{Call: _e.mock.On("Receive", ctx, f)}
}

func (_c *Subscription_Receive_Call) Run(run func(ctx context.Context, f func(context.Context, *pubsub.Message))) *Subscription_Receive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 func(context.Context, *pubsub.Message)
		if args[1] != nil {
			arg1 = args[1].(func(context.Context, *pubsub.Message))
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Subscription_Receive_Call) Return(err error) *Subscription_Receive_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Subscription_Receive_Call) RunAndReturn(run func(ctx context.Context, f func(context.Context, *pubsub.Message)) error) *Subscription_Receive_Call {
	_c.Call.Return(run)
	return _c
}

// SeekToSnapshot provides a mock function for the type Subscription
func (_mock *Subscription) SeekToSnapshot(ctx context.Context, snap pubsub0.Snapshot) error {
	ret := _mock.Called(ctx, snap)

	if len(ret) == 0 {
		panic("no return value specified for SeekToSnapshot")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, pubsub0.Snapshot) error); ok {
		r0 = returnFunc(ctx, snap)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Subscription_SeekToSnapshot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SeekToSnapshot'
type Subscription_SeekToSnapshot_Call struct {
	*mock.Call
}

// SeekToSnapshot is a helper method to define mock.On call
//   - ctx context.Context
//   - snap pubsub0.Snapshot
func (_e *Subscription_Expecter) SeekToSnapshot(ctx interface{}, snap interface{}) *Subscription_SeekToSnapshot_Call {
	return &Subscription_SeekToSnapshot_Call{Call: _e.mock.On("SeekToSnapshot", ctx, snap)}
}

func (_c *Subscription_SeekToSnapshot_Call) Run(run func(ctx context.Context, snap pubsub0.Snapshot)) *Subscription_SeekToSnapshot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 pubsub0.Snapshot
		if args[1] != nil {
			arg1 = args[1].(pubsub0.Snapshot)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Subscription_SeekToSnapshot_Call) Return(err error) *Subscription_SeekToSnapshot_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Subscription_SeekToSnapshot_Call) RunAndReturn(run func(ctx context.Context, snap pubsub0.Snapshot) error) *Subscription_SeekToSnapshot_Call {
	_c.Call.Return(run)
	return _c
}

// SeekToTime provides a mock function for the type Subscription
func (_mock *Subscription) SeekToTime(ctx context.Context, t time.Time) error {
	ret := _mock.Called(ctx, t)

	if len(ret) == 0 {
		panic("no return value specified for SeekToTime")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Time) error); ok {
		r0 = returnFunc(ctx, t)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Subscription_SeekToTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SeekToTime'
type Subscription_SeekToTime_Call struct {
	*mock.Call
}

// SeekToTime is a helper method to define mock.On call
//   - ctx context.Context
//   - t time.Time
func (_e *Subscription_Expecter) SeekToTime(ctx interface{}, t interface{}) *Subscription_SeekToTime_Call {
	return &Subscription_SeekToTime_Call{Call: _e.mock.On("SeekToTime", ctx, t)}
}

func (_c *Subscription_SeekToTime_Call) Run(run func(ctx context.Context, t time.Time)) *Subscription_SeekToTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 time.Time
		if args[1] != nil {
			arg1 = args[1].(time.Time)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Subscription_SeekToTime_Call) Return(err error) *Subscription_SeekToTime_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Subscription_SeekToTime_Call) RunAndReturn(run func(ctx context.Context, t time.Time) error) *Subscription_SeekToTime_Call {
	_c.Call.Return(run)
	return _c
}

// String provides a mock function for the type Subscription
func (_mock *Subscription) String() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for String")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// Subscription_String_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'String'
type Subscription_String_Call struct {
	*mock.Call
}

// String is a helper method to define mock.On call
func (_e *Subscription_Expecter) String() *Subscription_String_Call {
	return &Subscription_String_Call{Call: _e.mock.On("String")}
}

func (_c *Subscription_String_Call) Run(run func()) *Subscription_String_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Subscription_String_Call) Return(s string) *Subscription_String_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *Subscription_String_Call) RunAndReturn(run func() string) *Subscription_String_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type Subscription
func (_mock *Subscription) Update(ctx context.Context, cfg pubsub.SubscriptionConfigToUpdate) (pubsub.SubscriptionConfig, error) {
	ret := _mock.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 pubsub.SubscriptionConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, pubsub.SubscriptionConfigToUpdate) (pubsub.SubscriptionConfig, error)); ok {
		return returnFunc(ctx, cfg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, pubsub.SubscriptionConfigToUpdate) pubsub.SubscriptionConfig); ok {
		r0 = returnFunc(ctx, cfg)
	} else {
		r0 = ret.Get(0).(pubsub.SubscriptionConfig)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, pubsub.SubscriptionConfigToUpdate) error); ok {
		r1 = returnFunc(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Subscription_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type Subscription_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg pubsub.SubscriptionConfigToUpdate
func (_e *Subscription_Expecter) Update(ctx interface{}, cfg interface{}) *Subscription_Update_Call {
	return &Subscription_Update_Call{Call: _e.mock.On("Update", ctx, cfg)}
}

func (_c *Subscription_Update_Call) Run(run func(ctx context.Context, cfg pubsub.SubscriptionConfigToUpdate)) *Subscription_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 pubsub.SubscriptionConfigToUpdate
		if args[1] != nil {
			arg1 = args[1].(pubsub.SubscriptionConfigToUpdate)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Subscription_Update_Call) Return(subscriptionConfig pubsub.SubscriptionConfig, err error) *Subscription_Update_Call {
	_c.Call.Return(subscriptionConfig, err)
	return _c
}

func (_c *Subscription_Update_Call) RunAndReturn(run func(ctx context.Context, cfg pubsub.SubscriptionConfigToUpdate) (pubsub.SubscriptionConfig, error)) *Subscription_Update_Call {
	_c.Call.Return(run)
	return _c
}

// NewTopic creates a new instance of Topic. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTopic(t interface {
	mock.TestingT
	Cleanup(func())
}) *Topic {
	mock := &Topic{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Topic is an autogenerated mock type for the Topic type
type Topic struct {
	mock.Mock
}

type Topic_Expecter struct {
	mock *mock.Mock
}

func (_m *Topic) EXPECT() *Topic_Expecter {
	return &Topic_Expecter{mock: &_m.Mock}
}

// Config provides a mock function for the type Topic
func (_mock *Topic) Config(ctx context.Context) (pubsub.TopicConfig, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Config")
	}

	var r0 pubsub.TopicConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (pubsub.TopicConfig, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) pubsub.TopicConfig); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(pubsub.TopicConfig)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Topic_Config_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Config'
type Topic_Config_Call struct {
	*mock.Call
}

// Config is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Topic_Expecter) Config(ctx interface{}) *Topic_Config_Call {
	return &Topic_Config_Call{Call: _e.mock.On("Config", ctx)}
}

func (_c *Topic_Config_Call) Run(run func(ctx context.Context)) *Topic_Config_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Topic_Config_Call) Return(topicConfig pubsub.TopicConfig, err error) *Topic_Config_Call {
	_c.Call.Return(topicConfig, err)
	return _c
}

func (_c *Topic_Config_Call) RunAndReturn(run func(ctx context.Context) (pubsub.TopicConfig, error)) *Topic_Config_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type Topic
func (_mock *Topic) Delete(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Topic_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type Topic_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Topic_Expecter) Delete(ctx interface{}) *Topic_Delete_Call {
	return &Topic_Delete_Call{Call: _e.mock.On("Delete", ctx)}
}

func (_c *Topic_Delete_Call) Run(run func(ctx context.Context)) *Topic_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Topic_Delete_Call) Return(err error) *Topic_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Topic_Delete_Call) RunAndReturn(run func(ctx context.Context) error) *Topic_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type Topic
func (_mock *Topic) Exists(ctx context.Context) (bool, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (bool, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) bool); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Topic_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type Topic_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Topic_Expecter) Exists(ctx interface{}) *Topic_Exists_Call {
	return &Topic_Exists_Call{Call: _e.mock.On("Exists", ctx)}
}

func (_c *Topic_Exists_Call) Run(run func(ctx context.Context)) *Topic_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Topic_Exists_Call) Return(b bool, err error) *Topic_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *Topic_Exists_Call) RunAndReturn(run func(ctx context.Context) (bool, error)) *Topic_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Flush provides a mock function for the type Topic
func (_mock *Topic) Flush() {
	_mock.Called()
	return
}

// Topic_Flush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Flush'
type Topic_Flush_Call struct {
	*mock.Call
}

// Flush is a helper method to define mock.On call
func (_e *Topic_Expecter) Flush() *Topic_Flush_Call {
	return &Topic_Flush_Call{Call: _e.mock.On("Flush")}
}

func (_c *Topic_Flush_Call) Run(run func()) *Topic_Flush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Topic_Flush_Call) Return() *Topic_Flush_Call {
	_c.Call.Return()
	return _c
}

func (_c *Topic_Flush_Call) RunAndReturn(run func()) *Topic_Flush_Call {
	_c.Run(run)
	return _c
}

// IAM provides a mock function for the type Topic
func (_mock *Topic) IAM() *iam.Handle {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for IAM")
	}

	var r0 *iam.Handle
	if returnFunc, ok := ret.Get(0).(func() *iam.Handle); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*iam.Handle)
		}
	}
	return r0
}

// Topic_IAM_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IAM'
type Topic_IAM_Call struct {
	*mock.Call
}

// IAM is a helper method to define mock.On call
func (_e *Topic_Expecter) IAM() *Topic_IAM_Call {
	return &Topic_IAM_Call{Call: _e.mock.On("IAM")}
}

func (_c *Topic_IAM_Call) Run(run func()) *Topic_IAM_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Topic_IAM_Call) Return(handle *iam.Handle) *Topic_IAM_Call {
	_c.Call.Return(handle)
	return _c
}

func (_c *Topic_IAM_Call) RunAndReturn(run func() *iam.Handle) *Topic_IAM_Call {
	_c.Call.Return(run)
	return _c
}

// ID provides a mock function for the type Topic
func (_mock *Topic) ID() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ID")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// Topic_ID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ID'
type Topic_ID_Call struct {
	*mock.Call
}

// ID is a helper method to define mock.On call
func (_e *Topic_Expecter) ID() *Topic_ID_Call {
	return &Topic_ID_Call{Call: _e.mock.On("ID")}
}

func (_c *Topic_ID_Call) Run(run func()) *Topic_ID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Topic_ID_Call) Return(s string) *Topic_ID_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *Topic_ID_Call) RunAndReturn(run func() string) *Topic_ID_Call {
	_c.Call.Return(run)
	return _c
}

// Publish provides a mock function for the type Topic
func (_mock *Topic) Publish(ctx context.Context, msg *pubsub.Message) pubsub0.PublishResult {
	ret := _mock.Called(ctx, msg)

	if len(ret) == 0 {
		panic("no return value specified for Publish")
	}

	var r0 pubsub0.PublishResult
	if returnFunc, ok := ret.Get(0).(func(context.Context, *pubsub.Message) pubsub0.PublishResult); ok {
		r0 = returnFunc(ctx, msg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(pubsub0.PublishResult)
		}
	}
	return r0
}

// Topic_Publish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Publish'
type Topic_Publish_Call struct {
	*mock.Call
}

// Publish is a helper method to define mock.On call
//   - ctx context.Context
//   - msg *pubsub.Message
func (_e *Topic_Expecter) Publish(ctx interface{}, msg interface{}) *Topic_Publish_Call {
	return &Topic_Publish_Call{Call: _e.mock.On("Publish", ctx, msg)}
}

func (_c *Topic_Publish_Call) Run(run func(ctx context.Context, msg *pubsub.Message)) *Topic_Publish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *pubsub.Message
		if args[1] != nil {
			arg1 = args[1].(*pubsub.Message)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Topic_Publish_Call) Return(publishResult pubsub0.PublishResult) *Topic_Publish_Call {
	_c.Call.Return(publishResult)
	return _c
}

func (_c *Topic_Publish_Call) RunAndReturn(run func(ctx context.Context, msg *pubsub.Message) pubsub0.PublishResult) *Topic_Publish_Call {
	_c.Call.Return(run)
	return _c
}

// ResumePublish provides a mock function for the type Topic
func (_mock *Topic) ResumePublish(orderingKey string) {
	_mock.Called(orderingKey)
	return
}

// Topic_ResumePublish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResumePublish'
type Topic_ResumePublish_Call struct {
	*mock.Call
}

// ResumePublish is a helper method to define mock.On call
//   - orderingKey string
func (_e *Topic_Expecter) ResumePublish(orderingKey interface{}) *Topic_ResumePublish_Call {
	return &Topic_ResumePublish_Call{Call: _e.mock.On("ResumePublish", orderingKey)}
}

func (_c *Topic_ResumePublish_Call) Run(run func(orderingKey string)) *Topic_ResumePublish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Topic_ResumePublish_Call) Return() *Topic_ResumePublish_Call {
	_c.Call.Return()
	return _c
}

func (_c *Topic_ResumePublish_Call) RunAndReturn(run func(orderingKey string)) *Topic_ResumePublish_Call {
	_c.Run(run)
	return _c
}

// Stop provides a mock function for the type Topic
func (_mock *Topic) Stop() {
	_mock.Called()
	return
}

// Topic_Stop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stop'
type Topic_Stop_Call struct {
	*mock.Call
}

// Stop is a helper method to define mock.On call
func (_e *Topic_Expecter) Stop() *Topic_Stop_Call {
	return &Topic_Stop_Call{Call: _e.mock.On("Stop")}
}

func (_c *Topic_Stop_Call) Run(run func()) *Topic_Stop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Topic_Stop_Call) Return() *Topic_Stop_Call {
	_c.Call.Return()
	return _c
}

func (_c *Topic_Stop_Call) RunAndReturn(run func()) *Topic_Stop_Call {
	_c.Run(run)
	return _c
}

// String provides a mock function for the type Topic
func (_mock *Topic) String() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for String")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// Topic_String_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'String'
type Topic_String_Call struct {
	*mock.Call
}

// String is a helper method to define mock.On call
func (_e *Topic_Expecter) String() *Topic_String_Call {
	return &Topic_String_Call{Call: _e.mock.On("String")}
}

func (_c *Topic_String_Call) Run(run func()) *Topic_String_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Topic_String_Call) Return(s string) *Topic_String_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *Topic_String_Call) RunAndReturn(run func() string) *Topic_String_Call {
	_c.Call.Return(run)
	return _c
}

// Subscriptions provides a mock function for the type Topic
func (_mock *Topic) Subscriptions(ctx context.Context) *pubsub.SubscriptionIterator {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Subscriptions")
	}

	var r0 *pubsub.SubscriptionIterator
	if returnFunc, ok := ret.Get(0).(func(context.Context) *pubsub.SubscriptionIterator); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pubsub.SubscriptionIterator)
		}
	}
	return r0
}

// Topic_Subscriptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscriptions'
type Topic_Subscriptions_Call struct {
	*mock.Call
}

// Subscriptions is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Topic_Expecter) Subscriptions(ctx interface{}) *Topic_Subscriptions_Call {
	return &Topic_Subscriptions_Call{Call: _e.mock.On("Subscriptions", ctx)}
}

func (_c *Topic_Subscriptions_Call) Run(run func(ctx context.Context)) *Topic_Subscriptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *Topic_Subscriptions_Call) Return(subscriptionIterator *pubsub.SubscriptionIterator) *Topic_Subscriptions_Call {
	_c.Call.Return(subscriptionIterator)
	return _c
}

func (_c *Topic_Subscriptions_Call) RunAndReturn(run func(ctx context.Context) *pubsub.SubscriptionIterator) *Topic_Subscriptions_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type Topic
func (_mock *Topic) Update(ctx context.Context, cfg pubsub.TopicConfigToUpdate) (pubsub.TopicConfig, error) {
	ret := _mock.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 pubsub.TopicConfig
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, pubsub.TopicConfigToUpdate) (pubsub.TopicConfig, error)); ok {
		return returnFunc(ctx, cfg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, pubsub.TopicConfigToUpdate) pubsub.TopicConfig); ok {
		r0 = returnFunc(ctx, cfg)
	} else {
		r0 = ret.Get(0).(pubsub.TopicConfig)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, pubsub.TopicConfigToUpdate) error); ok {
		r1 = returnFunc(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Topic_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type Topic_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg pubsub.TopicConfigToUpdate
func (_e *Topic_Expecter) Update(ctx interface{}, cfg interface{}) *Topic_Update_Call {
	return &Topic_Update_Call{Call: _e.mock.On("Update", ctx, cfg)}
}

func (_c *Topic_Update_Call) Run(run func(ctx context.Context, cfg pubsub.TopicConfigToUpdate)) *Topic_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 pubsub.TopicConfigToUpdate
		if args[1] != nil {
			arg1 = args[1].(pubsub.TopicConfigToUpdate)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Topic_Update_Call) Return(topicConfig pubsub.TopicConfig, err error) *Topic_Update_Call {
	_c.Call.Return(topicConfig, err)
	return _c
}

func (_c *Topic_Update_Call) RunAndReturn(run func(ctx context.Context, cfg pubsub.TopicConfigToUpdate) (pubsub.TopicConfig, error)) *Topic_Update_Call {
	_c.Call.Return(run)
	return _c
}

// NewPublishResult creates a new instance of PublishResult. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPublishResult(t interface {
	mock.TestingT
	Cleanup(func())
}) *PublishResult {
	mock := &PublishResult{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// PublishResult is an autogenerated mock type for the PublishResult type
type PublishResult struct {
	mock.Mock
}

type PublishResult_Expecter struct {
	mock *mock.Mock
}

func (_m *PublishResult) EXPECT() *PublishResult_Expecter {
	return &PublishResult_Expecter{mock: &_m.Mock}
}

// Get provides a mock function for the type PublishResult
func (_mock *PublishResult) Get(ctx context.Context) (string, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (string, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// PublishResult_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type PublishResult_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
func (_e *PublishResult_Expecter) Get(ctx interface{}) *PublishResult_Get_Call {
	return &PublishResult_Get_Call{Call: _e.mock.On("Get", ctx)}
}

func (_c *PublishResult_Get_Call) Run(run func(ctx context.Context)) *PublishResult_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *PublishResult_Get_Call) Return(serverID string, err error) *PublishResult_Get_Call {
	_c.Call.Return(serverID, err)
	return _c
}

func (_c *PublishResult_Get_Call) RunAndReturn(run func(ctx context.Context) (string, error)) *PublishResult_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Ready provides a mock function for the type PublishResult
func (_mock *PublishResult) Ready() <-chan struct{} {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ready")
	}

	var r0 <-chan struct{}
	if returnFunc, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}
	return r0
}

// PublishResult_Ready_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ready'
type PublishResult_Ready_Call struct {
	*mock.Call
}

// Ready is a helper method to define mock.On call
func (_e *PublishResult_Expecter) Ready() *PublishResult_Ready_Call {
	return &PublishResult_Ready_Call{Call: _e.mock.On("Ready")}
}

func (_c *PublishResult_Ready_Call) Run(run func()) *PublishResult_Ready_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *PublishResult_Ready_Call) Return(valCh <-chan struct{}) *PublishResult_Ready_Call {
	_c.Call.Return(valCh)
	return _c
}

func (_c *PublishResult_Ready_Call) RunAndReturn(run func() <-chan struct{}) *PublishResult_Ready_Call {
	_c.Call.Return(run)
	return _c
}
