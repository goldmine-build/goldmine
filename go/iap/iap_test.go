package iap

import (
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	jwt "github.com/dgrijalva/jwt-go"
	"github.com/stretchr/testify/assert"
	"go.skia.org/infra/go/mockhttpclient"
	"go.skia.org/infra/go/testutils"
)

const AUD = "/projects/145247227042/global/backendServices/k8s-be-32071--e03569f20c11b77d"

func TestBasics(t *testing.T) {
	testutils.SmallTest(t)
	ih := New(nil, AUD, nil)
	assert.Equal(t, AUD, ih.aud)
}

func TestFindKey(t *testing.T) {
	testutils.SmallTest(t)
	ih := New(nil, AUD, nil)

	m := mockhttpclient.NewURLMock()
	m.MockOnce(IAP_PUBLIC_KEY_URL, mockhttpclient.MockGetDialogue([]byte(`{"foo": "bar"}`)))
	m.MockOnce(IAP_PUBLIC_KEY_URL, mockhttpclient.MockGetDialogue([]byte(`{"foo": "bar"}`)))
	m.MockOnce(IAP_PUBLIC_KEY_URL, mockhttpclient.MockGetDialogue([]byte(`{"foo": "bar", "baz": "quxx"}`)))
	ih.client = m.Client()

	// Make request on empty keys and force an http request.
	key, err := ih.findKey("foo")
	assert.NoError(t, err)
	assert.Equal(t, "bar", key)
	assert.Len(t, ih.keys, 1)

	// Make request on key that is in cache, no http request.
	key, err = ih.findKey("foo")
	assert.NoError(t, err)
	assert.Equal(t, "bar", key)
	assert.Len(t, ih.keys, 1)

	// Make request for missing key and force an http request, and the key isn't there.
	_, err = ih.findKey("baz")
	assert.Error(t, err)
	assert.Len(t, ih.keys, 1)

	// Make request for missing key and force an http request, and the key is now present.
	key, err = ih.findKey("baz")
	assert.NoError(t, err)
	assert.Equal(t, "quxx", key)
	assert.Len(t, ih.keys, 2)
}

func TestEmail(t *testing.T) {
	testutils.SmallTest(t)
	ih := New(nil, AUD, nil)

	email, err := ih.getEmail("a.b.c")
	assert.Equal(t, errNotFound, err)

	ih.setEmail("a.b.c", "fred@example.org")

	email, err = ih.getEmail("a.b.c")
	assert.NoError(t, err)
	assert.Equal(t, "fred@example.org", email)
}

func TestServe(t *testing.T) {
	testutils.SmallTest(t)
	ih := New(nil, AUD, nil)

	// Good healtcheck.
	r := httptest.NewRequest("GET", "http://example.com/", nil)
	r.RemoteAddr = "10.0.0.1:8080"
	w := httptest.NewRecorder()
	ih.ServeHTTP(w, r)
	resp := w.Result()
	assert.Equal(t, 200, resp.StatusCode)

	// Add a user that has already been validated.
	ih.handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		_, err := io.WriteString(w, "<html><body>Hello World!</body></html>")
		assert.NoError(t, err)
	})
	ih.setEmail("a.b.c", "fred@example.com")

	r = httptest.NewRequest("GET", "http://example.com/foo", nil)
	r.Header.Set("x-goog-iap-jwt-assertion", "a.b.c")
	w = httptest.NewRecorder()
	ih.ServeHTTP(w, r)
	resp = w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	assert.Equal(t, "<html><body>Hello World!</body></html>", string(body))
	assert.Equal(t, 200, resp.StatusCode)
	assert.Equal(t, "fred@example.com", r.Header.Get(EMAIL_HEADER))

	// Root request, non-healthcheck.
	r = httptest.NewRequest("GET", "http://example.com/", nil)
	r.Header.Set("x-goog-iap-jwt-assertion", "a.b.c")
	w = httptest.NewRecorder()
	ih.ServeHTTP(w, r)
	resp = w.Result()
	body, _ = ioutil.ReadAll(resp.Body)
	assert.Equal(t, "<html><body>Hello World!</body></html>", string(body))
	assert.Equal(t, 200, resp.StatusCode)
	assert.Equal(t, "fred@example.com", r.Header.Get(EMAIL_HEADER))
}

func goodClaimsAndTokenFor(email string) (jwt.MapClaims, *jwt.Token) {
	// Create a new token object, specifying signing method and the claims
	// you would like it to contain.
	now := time.Now()

	claims := jwt.MapClaims{
		"iat":   now.Unix(),
		"exp":   now.Add(time.Hour).Unix(),
		"aud":   AUD,
		"iss":   "https://cloud.google.com/iap",
		"nbf":   time.Date(2015, 10, 10, 12, 0, 0, 0, time.UTC).Unix(),
		"email": email,
		"hd":    "google.com",
	}

	token := jwt.NewWithClaims(jwt.SigningMethodES256, claims)
	token.Header["alg"] = "ES256"
	token.Header["kid"] = "foo"
	return claims, token
}

func goodClaimsAndToken() (jwt.MapClaims, *jwt.Token) {
	return goodClaimsAndTokenFor("test@example.org")
}

func TestSigning(t *testing.T) {
	testutils.SmallTest(t)
	var h http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		_, err := io.WriteString(w, "<html><body>Hello World!</body></html>")
		assert.NoError(t, err)
	})
	ih := New(h, AUD, nil)

	_, token := goodClaimsAndToken()

	// The test public and private keys were generated by running:
	// $ openssl ecparam -genkey -name prime256v1 -noout -out ec_private.pem
	// $ openssl ec -in ec_private.pem -pubout -out ec_public.pem

	// We obfuscate the private key to avoid getting flagged by scanners looking
	// for actual private keys that need to be kept private.
	private := fmt.Sprintf(`-----BEGIN EC %s KEY-----
MHcCAQEEIF/CmKlaP9rhGZi4xbhun+xpLjYHrux57KoLilrYwYqzoAoGCCqGSM49
AwEHoUQDQgAE8JvCczoQZVRKtlbQvaaxcT7OJX7QlMgnmZhQXYTaxTcUmaV2zxD/
U3fSoPyzliWdVHK6Zc5wW6kYVYuT5e9/Kg==
-----END EC %s KEY-----
`, "PRIVATE", "PRIVATE")
	public := `-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE8JvCczoQZVRKtlbQvaaxcT7OJX7Q
lMgnmZhQXYTaxTcUmaV2zxD/U3fSoPyzliWdVHK6Zc5wW6kYVYuT5e9/Kg==
-----END PUBLIC KEY-----
`
	// Parse the private key.
	key, err := jwt.ParseECPrivateKeyFromPEM([]byte(private))
	assert.NoError(t, err)

	// Sign and get the complete encoded token as a string using the private key.
	tokenString, err := token.SignedString(key)
	assert.NoError(t, err)

	// Mock out the request for the associated public key.
	m := mockhttpclient.NewURLMock()
	public_keys := map[string]string{"foo": string(public)}
	public_keys_json, err := json.Marshal(public_keys)
	assert.NoError(t, err)
	m.Mock(IAP_PUBLIC_KEY_URL, mockhttpclient.MockGetDialogue([]byte(public_keys_json)))
	ih.client = m.Client()

	r := httptest.NewRequest("GET", "http://example.com/", nil)
	r.Header.Set("x-goog-iap-jwt-assertion", tokenString)
	w := httptest.NewRecorder()
	ih.ServeHTTP(w, r)
	resp := w.Result()
	body, _ := ioutil.ReadAll(resp.Body)
	assert.Equal(t, "<html><body>Hello World!</body></html>", string(body))
	assert.Equal(t, 200, resp.StatusCode)
	assert.Equal(t, "test@example.org", r.Header.Get(EMAIL_HEADER))

	// Now remove claims one at a time and confirm we get a 500 each time.
	for _, remove := range []string{"iat", "exp", "aud", "iss", "email"} {
		claims, token := goodClaimsAndToken()

		tokenString, err := token.SignedString(key)
		assert.NoError(t, err)
		r := httptest.NewRequest("GET", "http://example.com/foo", nil)
		r.Header.Set("x-goog-iap-jwt-assertion", tokenString)
		w := httptest.NewRecorder()
		ih.ServeHTTP(w, r)
		assert.Equal(t, 200, w.Result().StatusCode)

		// Test that the claim is bad when a single claim is removed.
		delete(claims, remove)

		token = jwt.NewWithClaims(jwt.SigningMethodES256, claims)
		token.Header["alg"] = "ES256"
		token.Header["kid"] = "foo"
		tokenString, err = token.SignedString(key)
		assert.NoError(t, err)
		r = httptest.NewRequest("GET", "http://example.com/foo", nil)
		r.Header.Set("x-goog-iap-jwt-assertion", tokenString)
		w = httptest.NewRecorder()
		ih.ServeHTTP(w, r)
		assert.Equal(t, 500, w.Result().StatusCode)
	}

	// Now test Allow support.
	_, token = goodClaimsAndToken()
	tokenString, err = token.SignedString(key)
	assert.NoError(t, err)
	r = httptest.NewRequest("GET", "http://example.com/foo", nil)
	r.Header.Set("x-goog-iap-jwt-assertion", tokenString)

	// User is allowed.
	w = httptest.NewRecorder()
	ih.allow = NewAllowedFromList([]string{"test@example.org"})
	ih.ServeHTTP(w, r)
	assert.Equal(t, 200, w.Result().StatusCode)

	// Access has been revoked.
	w = httptest.NewRecorder()
	ih.allow = NewAllowedFromList([]string{"chromium.org"})
	ih.ServeHTTP(w, r)
	assert.Equal(t, 401, w.Result().StatusCode)

	// Access has been removed, with a novel email.
	_, token = goodClaimsAndTokenFor("somebodyelse@example.org")
	tokenString, err = token.SignedString(key)
	assert.NoError(t, err)
	r = httptest.NewRequest("GET", "http://example.com/foo", nil)
	r.Header.Set("x-goog-iap-jwt-assertion", tokenString)
	w = httptest.NewRecorder()
	ih.allow = NewAllowedFromList([]string{"chromium.org"})
	ih.ServeHTTP(w, r)
	assert.Equal(t, 401, w.Result().StatusCode)
}

func TestNone(t *testing.T) {
	testutils.SmallTest(t)
	var h http.Handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		_, err := io.WriteString(w, "Hello World!")
		assert.NoError(t, err)
	})
	// Test w/o None in place.
	r := httptest.NewRequest("GET", "http://example.com/foo", nil)
	r.Header.Set(SCHEME_AT_LOAD_BALANCER_HEADER, "http")
	w := httptest.NewRecorder()
	h.ServeHTTP(w, r)
	assert.Equal(t, 200, w.Result().StatusCode)
	assert.Equal(t, "", w.Result().Header.Get("Location"))
	b, err := ioutil.ReadAll(w.Result().Body)
	assert.NoError(t, err)
	assert.Len(t, b, 12)

	// Add in None behavior.
	h = None(h)
	w = httptest.NewRecorder()
	h.ServeHTTP(w, r)
	assert.Equal(t, 301, w.Result().StatusCode)
	assert.Equal(t, "https://example.com/foo", w.Result().Header.Get("Location"))

	// Test the healthcheck handling.
	r = httptest.NewRequest("GET", "http://example.com/", nil)
	r.Header.Set("User-Agent", "GoogleHC/1.0")
	w = httptest.NewRecorder()
	h.ServeHTTP(w, r)
	assert.Equal(t, 200, w.Result().StatusCode)
	assert.Equal(t, "", w.Result().Header.Get("Location"))
	b, err = ioutil.ReadAll(w.Result().Body)
	assert.NoError(t, err)
	assert.Len(t, b, 0)
}
