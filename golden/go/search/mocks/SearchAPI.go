// Code generated by mockery v2.4.0. DO NOT EDIT.

package mocks

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
	frontend "go.skia.org/infra/golden/go/search/frontend"

	query "go.skia.org/infra/golden/go/search/query"

	tjstore "go.skia.org/infra/golden/go/tjstore"

	types "go.skia.org/infra/golden/go/types"
)

// SearchAPI is an autogenerated mock type for the SearchAPI type
type SearchAPI struct {
	mock.Mock
}

// DiffDigests provides a mock function with given fields: ctx, t, left, right, clID, crs
func (_m *SearchAPI) DiffDigests(ctx context.Context, t types.TestName, left types.Digest, right types.Digest, clID string, crs string) (*frontend.DigestComparison, error) {
	ret := _m.Called(ctx, t, left, right, clID, crs)

	var r0 *frontend.DigestComparison
	if rf, ok := ret.Get(0).(func(context.Context, types.TestName, types.Digest, types.Digest, string, string) *frontend.DigestComparison); ok {
		r0 = rf(ctx, t, left, right, clID, crs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frontend.DigestComparison)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.TestName, types.Digest, types.Digest, string, string) error); ok {
		r1 = rf(ctx, t, left, right, clID, crs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDigestDetails provides a mock function with given fields: ctx, t, d, clID, crs
func (_m *SearchAPI) GetDigestDetails(ctx context.Context, t types.TestName, d types.Digest, clID string, crs string) (*frontend.DigestDetails, error) {
	ret := _m.Called(ctx, t, d, clID, crs)

	var r0 *frontend.DigestDetails
	if rf, ok := ret.Get(0).(func(context.Context, types.TestName, types.Digest, string, string) *frontend.DigestDetails); ok {
		r0 = rf(ctx, t, d, clID, crs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frontend.DigestDetails)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.TestName, types.Digest, string, string) error); ok {
		r1 = rf(ctx, t, d, clID, crs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Search provides a mock function with given fields: _a0, _a1
func (_m *SearchAPI) Search(_a0 context.Context, _a1 *query.Search) (*frontend.SearchResponse, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *frontend.SearchResponse
	if rf, ok := ret.Get(0).(func(context.Context, *query.Search) *frontend.SearchResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frontend.SearchResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *query.Search) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UntriagedUnignoredTryJobExclusiveDigests provides a mock function with given fields: _a0, _a1
func (_m *SearchAPI) UntriagedUnignoredTryJobExclusiveDigests(_a0 context.Context, _a1 tjstore.CombinedPSID) (*frontend.UntriagedDigestList, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *frontend.UntriagedDigestList
	if rf, ok := ret.Get(0).(func(context.Context, tjstore.CombinedPSID) *frontend.UntriagedDigestList); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*frontend.UntriagedDigestList)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, tjstore.CombinedPSID) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
