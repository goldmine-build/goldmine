package indexer

import (
	"context"
	"time"

	"go.skia.org/infra/go/paramtools"
	"go.skia.org/infra/golden/go/blame"
	"go.skia.org/infra/golden/go/digest_counter"
	"go.skia.org/infra/golden/go/summary"
	"go.skia.org/infra/golden/go/tiling"
	"go.skia.org/infra/golden/go/tjstore"
	"go.skia.org/infra/golden/go/types"
)

type IndexSource interface {
	// GetIndex returns an IndexSearcher, which can be considered immutable (the underlying
	// Tile won't change). It should be used to handle an entire request to provide
	// consistent information.
	GetIndex() IndexSearcher

	// GetIndexForCL returns an index object for a given ChangeList.
	GetIndexForCL(crs, clID string) *ChangeListIndex
}

type IndexSearcher interface {
	// Tile returns the current complex tile from which simpler tiles, like one without ignored
	// traces, can be retrieved
	Tile() tiling.ComplexTile

	// GetIgnoreMatcher returns a matcher for the ignore rules that were used to
	// build the tile with ignores.
	GetIgnoreMatcher() paramtools.ParamMatcher

	// DigestCountsByTest returns the counts of digests grouped by test name.
	DigestCountsByTest(is types.IgnoreState) map[types.TestName]digest_counter.DigestCount

	// MaxDigestsByTest returns the digests per test that were seen the most.
	MaxDigestsByTest(is types.IgnoreState) map[types.TestName]types.DigestSet

	// DigestCountsByTrace returns the counts of digests grouped by trace id.
	DigestCountsByTrace(is types.IgnoreState) map[tiling.TraceID]digest_counter.DigestCount

	// DigestCountsByQuery returns a DigestCount of all the digests that match the given query.
	DigestCountsByQuery(query paramtools.ParamSet, is types.IgnoreState) digest_counter.DigestCount

	// GetSummaries returns all summaries that were computed for this index.
	GetSummaries(is types.IgnoreState) []*summary.TriageStatus

	// SummarizeByGrouping returns those summaries from a given corpus that match the given inputs.
	// They may be filtered by any of: query, is at head or not.
	SummarizeByGrouping(ctx context.Context, corpus string, query paramtools.ParamSet, is types.IgnoreState, head bool) ([]*summary.TriageStatus, error)

	// GetParamsetSummary Returns the ParamSetSummary that matches the given test/digest.
	GetParamsetSummary(test types.TestName, digest types.Digest, is types.IgnoreState) paramtools.ParamSet

	// GetParamsetSummaryByTest returns all ParamSetSummaries in this tile grouped by test name.
	GetParamsetSummaryByTest(is types.IgnoreState) map[types.TestName]map[types.Digest]paramtools.ParamSet

	// GetBlame returns the blame computed for the given test/digest.
	GetBlame(test types.TestName, digest types.Digest, commits []*tiling.Commit) blame.BlameDistribution

	// SlicedTraces returns a slice of TracePairs that match the query and the ignore state.
	// This is meant to be a partial slice, as only the corpus and testname from the query are
	// used to create the subslice.
	SlicedTraces(is types.IgnoreState, query map[string][]string) []*tiling.TracePair

	// MostRecentPositiveDigest returns the most recent positive digest for the given trace.
	MostRecentPositiveDigest(ctx context.Context, traceID tiling.TraceID) (types.Digest, error)
}

type ChangeListIndex struct {
	// UntriagedResultsProduced is a map of all results that were untriaged the last time the index
	// was built.
	UntriagedResultsProduced map[tjstore.CombinedPSID][]tjstore.TryJobResult

	// TODO(kjlubick) Also include the paramset of the output generated by this CL. This will allow
	//  us to filter on the UI side by the params included in the CL.

	// ComputedTS is when this index was created. This helps clients determine how fresh the data is.
	ComputedTS time.Time
}

// Copy returns a deep copy of the ChangeListIndex.
func (c *ChangeListIndex) Copy() *ChangeListIndex {
	rv := &ChangeListIndex{
		ComputedTS:               c.ComputedTS,
		UntriagedResultsProduced: make(map[tjstore.CombinedPSID][]tjstore.TryJobResult, len(c.UntriagedResultsProduced)),
	}
	// Copy the map values
	for key, xtr := range c.UntriagedResultsProduced {
		newTr := make([]tjstore.TryJobResult, len(xtr))
		copy(newTr, xtr)
		rv.UntriagedResultsProduced[key] = newTr
	}
	return rv
}
