// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"time"

	mock "github.com/stretchr/testify/mock"
	"go.skia.org/infra/go/paramtools"
	"go.skia.org/infra/go/query"
	"go.skia.org/infra/perf/go/git/provider"
	"go.skia.org/infra/perf/go/tracestore"
	"go.skia.org/infra/perf/go/types"
)

// NewTraceStore creates a new instance of TraceStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTraceStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *TraceStore {
	mock := &TraceStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TraceStore is an autogenerated mock type for the TraceStore type
type TraceStore struct {
	mock.Mock
}

type TraceStore_Expecter struct {
	mock *mock.Mock
}

func (_m *TraceStore) EXPECT() *TraceStore_Expecter {
	return &TraceStore_Expecter{mock: &_m.Mock}
}

// CommitNumberOfTileStart provides a mock function for the type TraceStore
func (_mock *TraceStore) CommitNumberOfTileStart(commitNumber types.CommitNumber) types.CommitNumber {
	ret := _mock.Called(commitNumber)

	if len(ret) == 0 {
		panic("no return value specified for CommitNumberOfTileStart")
	}

	var r0 types.CommitNumber
	if returnFunc, ok := ret.Get(0).(func(types.CommitNumber) types.CommitNumber); ok {
		r0 = returnFunc(commitNumber)
	} else {
		r0 = ret.Get(0).(types.CommitNumber)
	}
	return r0
}

// TraceStore_CommitNumberOfTileStart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CommitNumberOfTileStart'
type TraceStore_CommitNumberOfTileStart_Call struct {
	*mock.Call
}

// CommitNumberOfTileStart is a helper method to define mock.On call
//   - commitNumber types.CommitNumber
func (_e *TraceStore_Expecter) CommitNumberOfTileStart(commitNumber interface{}) *TraceStore_CommitNumberOfTileStart_Call {
	return &TraceStore_CommitNumberOfTileStart_Call{Call: _e.mock.On("CommitNumberOfTileStart", commitNumber)}
}

func (_c *TraceStore_CommitNumberOfTileStart_Call) Run(run func(commitNumber types.CommitNumber)) *TraceStore_CommitNumberOfTileStart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 types.CommitNumber
		if args[0] != nil {
			arg0 = args[0].(types.CommitNumber)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TraceStore_CommitNumberOfTileStart_Call) Return(commitNumber1 types.CommitNumber) *TraceStore_CommitNumberOfTileStart_Call {
	_c.Call.Return(commitNumber1)
	return _c
}

func (_c *TraceStore_CommitNumberOfTileStart_Call) RunAndReturn(run func(commitNumber types.CommitNumber) types.CommitNumber) *TraceStore_CommitNumberOfTileStart_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastNSources provides a mock function for the type TraceStore
func (_mock *TraceStore) GetLastNSources(ctx context.Context, traceID string, n int) ([]tracestore.Source, error) {
	ret := _mock.Called(ctx, traceID, n)

	if len(ret) == 0 {
		panic("no return value specified for GetLastNSources")
	}

	var r0 []tracestore.Source
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int) ([]tracestore.Source, error)); ok {
		return returnFunc(ctx, traceID, n)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int) []tracestore.Source); ok {
		r0 = returnFunc(ctx, traceID, n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]tracestore.Source)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, int) error); ok {
		r1 = returnFunc(ctx, traceID, n)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TraceStore_GetLastNSources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastNSources'
type TraceStore_GetLastNSources_Call struct {
	*mock.Call
}

// GetLastNSources is a helper method to define mock.On call
//   - ctx context.Context
//   - traceID string
//   - n int
func (_e *TraceStore_Expecter) GetLastNSources(ctx interface{}, traceID interface{}, n interface{}) *TraceStore_GetLastNSources_Call {
	return &TraceStore_GetLastNSources_Call{Call: _e.mock.On("GetLastNSources", ctx, traceID, n)}
}

func (_c *TraceStore_GetLastNSources_Call) Run(run func(ctx context.Context, traceID string, n int)) *TraceStore_GetLastNSources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *TraceStore_GetLastNSources_Call) Return(sources []tracestore.Source, err error) *TraceStore_GetLastNSources_Call {
	_c.Call.Return(sources, err)
	return _c
}

func (_c *TraceStore_GetLastNSources_Call) RunAndReturn(run func(ctx context.Context, traceID string, n int) ([]tracestore.Source, error)) *TraceStore_GetLastNSources_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestTile provides a mock function for the type TraceStore
func (_mock *TraceStore) GetLatestTile(context1 context.Context) (types.TileNumber, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestTile")
	}

	var r0 types.TileNumber
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (types.TileNumber, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) types.TileNumber); ok {
		r0 = returnFunc(context1)
	} else {
		r0 = ret.Get(0).(types.TileNumber)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TraceStore_GetLatestTile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestTile'
type TraceStore_GetLatestTile_Call struct {
	*mock.Call
}

// GetLatestTile is a helper method to define mock.On call
//   - context1 context.Context
func (_e *TraceStore_Expecter) GetLatestTile(context1 interface{}) *TraceStore_GetLatestTile_Call {
	return &TraceStore_GetLatestTile_Call{Call: _e.mock.On("GetLatestTile", context1)}
}

func (_c *TraceStore_GetLatestTile_Call) Run(run func(context1 context.Context)) *TraceStore_GetLatestTile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TraceStore_GetLatestTile_Call) Return(tileNumber types.TileNumber, err error) *TraceStore_GetLatestTile_Call {
	_c.Call.Return(tileNumber, err)
	return _c
}

func (_c *TraceStore_GetLatestTile_Call) RunAndReturn(run func(context1 context.Context) (types.TileNumber, error)) *TraceStore_GetLatestTile_Call {
	_c.Call.Return(run)
	return _c
}

// GetParamSet provides a mock function for the type TraceStore
func (_mock *TraceStore) GetParamSet(ctx context.Context, tileNumber types.TileNumber) (paramtools.ReadOnlyParamSet, error) {
	ret := _mock.Called(ctx, tileNumber)

	if len(ret) == 0 {
		panic("no return value specified for GetParamSet")
	}

	var r0 paramtools.ReadOnlyParamSet
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TileNumber) (paramtools.ReadOnlyParamSet, error)); ok {
		return returnFunc(ctx, tileNumber)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TileNumber) paramtools.ReadOnlyParamSet); ok {
		r0 = returnFunc(ctx, tileNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(paramtools.ReadOnlyParamSet)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TileNumber) error); ok {
		r1 = returnFunc(ctx, tileNumber)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TraceStore_GetParamSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetParamSet'
type TraceStore_GetParamSet_Call struct {
	*mock.Call
}

// GetParamSet is a helper method to define mock.On call
//   - ctx context.Context
//   - tileNumber types.TileNumber
func (_e *TraceStore_Expecter) GetParamSet(ctx interface{}, tileNumber interface{}) *TraceStore_GetParamSet_Call {
	return &TraceStore_GetParamSet_Call{Call: _e.mock.On("GetParamSet", ctx, tileNumber)}
}

func (_c *TraceStore_GetParamSet_Call) Run(run func(ctx context.Context, tileNumber types.TileNumber)) *TraceStore_GetParamSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 types.TileNumber
		if args[1] != nil {
			arg1 = args[1].(types.TileNumber)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TraceStore_GetParamSet_Call) Return(readOnlyParamSet paramtools.ReadOnlyParamSet, err error) *TraceStore_GetParamSet_Call {
	_c.Call.Return(readOnlyParamSet, err)
	return _c
}

func (_c *TraceStore_GetParamSet_Call) RunAndReturn(run func(ctx context.Context, tileNumber types.TileNumber) (paramtools.ReadOnlyParamSet, error)) *TraceStore_GetParamSet_Call {
	_c.Call.Return(run)
	return _c
}

// GetSource provides a mock function for the type TraceStore
func (_mock *TraceStore) GetSource(ctx context.Context, commitNumber types.CommitNumber, traceId string) (string, error) {
	ret := _mock.Called(ctx, commitNumber, traceId)

	if len(ret) == 0 {
		panic("no return value specified for GetSource")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.CommitNumber, string) (string, error)); ok {
		return returnFunc(ctx, commitNumber, traceId)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.CommitNumber, string) string); ok {
		r0 = returnFunc(ctx, commitNumber, traceId)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.CommitNumber, string) error); ok {
		r1 = returnFunc(ctx, commitNumber, traceId)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TraceStore_GetSource_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSource'
type TraceStore_GetSource_Call struct {
	*mock.Call
}

// GetSource is a helper method to define mock.On call
//   - ctx context.Context
//   - commitNumber types.CommitNumber
//   - traceId string
func (_e *TraceStore_Expecter) GetSource(ctx interface{}, commitNumber interface{}, traceId interface{}) *TraceStore_GetSource_Call {
	return &TraceStore_GetSource_Call{Call: _e.mock.On("GetSource", ctx, commitNumber, traceId)}
}

func (_c *TraceStore_GetSource_Call) Run(run func(ctx context.Context, commitNumber types.CommitNumber, traceId string)) *TraceStore_GetSource_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 types.CommitNumber
		if args[1] != nil {
			arg1 = args[1].(types.CommitNumber)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *TraceStore_GetSource_Call) Return(s string, err error) *TraceStore_GetSource_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *TraceStore_GetSource_Call) RunAndReturn(run func(ctx context.Context, commitNumber types.CommitNumber, traceId string) (string, error)) *TraceStore_GetSource_Call {
	_c.Call.Return(run)
	return _c
}

// GetTraceIDsBySource provides a mock function for the type TraceStore
func (_mock *TraceStore) GetTraceIDsBySource(ctx context.Context, sourceFilename string, tileNumber types.TileNumber) ([]string, error) {
	ret := _mock.Called(ctx, sourceFilename, tileNumber)

	if len(ret) == 0 {
		panic("no return value specified for GetTraceIDsBySource")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, types.TileNumber) ([]string, error)); ok {
		return returnFunc(ctx, sourceFilename, tileNumber)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, types.TileNumber) []string); ok {
		r0 = returnFunc(ctx, sourceFilename, tileNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, types.TileNumber) error); ok {
		r1 = returnFunc(ctx, sourceFilename, tileNumber)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TraceStore_GetTraceIDsBySource_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTraceIDsBySource'
type TraceStore_GetTraceIDsBySource_Call struct {
	*mock.Call
}

// GetTraceIDsBySource is a helper method to define mock.On call
//   - ctx context.Context
//   - sourceFilename string
//   - tileNumber types.TileNumber
func (_e *TraceStore_Expecter) GetTraceIDsBySource(ctx interface{}, sourceFilename interface{}, tileNumber interface{}) *TraceStore_GetTraceIDsBySource_Call {
	return &TraceStore_GetTraceIDsBySource_Call{Call: _e.mock.On("GetTraceIDsBySource", ctx, sourceFilename, tileNumber)}
}

func (_c *TraceStore_GetTraceIDsBySource_Call) Run(run func(ctx context.Context, sourceFilename string, tileNumber types.TileNumber)) *TraceStore_GetTraceIDsBySource_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 types.TileNumber
		if args[2] != nil {
			arg2 = args[2].(types.TileNumber)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *TraceStore_GetTraceIDsBySource_Call) Return(strings []string, err error) *TraceStore_GetTraceIDsBySource_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *TraceStore_GetTraceIDsBySource_Call) RunAndReturn(run func(ctx context.Context, sourceFilename string, tileNumber types.TileNumber) ([]string, error)) *TraceStore_GetTraceIDsBySource_Call {
	_c.Call.Return(run)
	return _c
}

// OffsetFromCommitNumber provides a mock function for the type TraceStore
func (_mock *TraceStore) OffsetFromCommitNumber(commitNumber types.CommitNumber) int32 {
	ret := _mock.Called(commitNumber)

	if len(ret) == 0 {
		panic("no return value specified for OffsetFromCommitNumber")
	}

	var r0 int32
	if returnFunc, ok := ret.Get(0).(func(types.CommitNumber) int32); ok {
		r0 = returnFunc(commitNumber)
	} else {
		r0 = ret.Get(0).(int32)
	}
	return r0
}

// TraceStore_OffsetFromCommitNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OffsetFromCommitNumber'
type TraceStore_OffsetFromCommitNumber_Call struct {
	*mock.Call
}

// OffsetFromCommitNumber is a helper method to define mock.On call
//   - commitNumber types.CommitNumber
func (_e *TraceStore_Expecter) OffsetFromCommitNumber(commitNumber interface{}) *TraceStore_OffsetFromCommitNumber_Call {
	return &TraceStore_OffsetFromCommitNumber_Call{Call: _e.mock.On("OffsetFromCommitNumber", commitNumber)}
}

func (_c *TraceStore_OffsetFromCommitNumber_Call) Run(run func(commitNumber types.CommitNumber)) *TraceStore_OffsetFromCommitNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 types.CommitNumber
		if args[0] != nil {
			arg0 = args[0].(types.CommitNumber)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TraceStore_OffsetFromCommitNumber_Call) Return(n int32) *TraceStore_OffsetFromCommitNumber_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *TraceStore_OffsetFromCommitNumber_Call) RunAndReturn(run func(commitNumber types.CommitNumber) int32) *TraceStore_OffsetFromCommitNumber_Call {
	_c.Call.Return(run)
	return _c
}

// QueryTraces provides a mock function for the type TraceStore
func (_mock *TraceStore) QueryTraces(ctx context.Context, tileNumber types.TileNumber, q *query.Query) (types.TraceSet, []provider.Commit, error) {
	ret := _mock.Called(ctx, tileNumber, q)

	if len(ret) == 0 {
		panic("no return value specified for QueryTraces")
	}

	var r0 types.TraceSet
	var r1 []provider.Commit
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TileNumber, *query.Query) (types.TraceSet, []provider.Commit, error)); ok {
		return returnFunc(ctx, tileNumber, q)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TileNumber, *query.Query) types.TraceSet); ok {
		r0 = returnFunc(ctx, tileNumber, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.TraceSet)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TileNumber, *query.Query) []provider.Commit); ok {
		r1 = returnFunc(ctx, tileNumber, q)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]provider.Commit)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, types.TileNumber, *query.Query) error); ok {
		r2 = returnFunc(ctx, tileNumber, q)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// TraceStore_QueryTraces_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryTraces'
type TraceStore_QueryTraces_Call struct {
	*mock.Call
}

// QueryTraces is a helper method to define mock.On call
//   - ctx context.Context
//   - tileNumber types.TileNumber
//   - q *query.Query
func (_e *TraceStore_Expecter) QueryTraces(ctx interface{}, tileNumber interface{}, q interface{}) *TraceStore_QueryTraces_Call {
	return &TraceStore_QueryTraces_Call{Call: _e.mock.On("QueryTraces", ctx, tileNumber, q)}
}

func (_c *TraceStore_QueryTraces_Call) Run(run func(ctx context.Context, tileNumber types.TileNumber, q *query.Query)) *TraceStore_QueryTraces_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 types.TileNumber
		if args[1] != nil {
			arg1 = args[1].(types.TileNumber)
		}
		var arg2 *query.Query
		if args[2] != nil {
			arg2 = args[2].(*query.Query)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *TraceStore_QueryTraces_Call) Return(traceSet types.TraceSet, commits []provider.Commit, err error) *TraceStore_QueryTraces_Call {
	_c.Call.Return(traceSet, commits, err)
	return _c
}

func (_c *TraceStore_QueryTraces_Call) RunAndReturn(run func(ctx context.Context, tileNumber types.TileNumber, q *query.Query) (types.TraceSet, []provider.Commit, error)) *TraceStore_QueryTraces_Call {
	_c.Call.Return(run)
	return _c
}

// QueryTracesIDOnly provides a mock function for the type TraceStore
func (_mock *TraceStore) QueryTracesIDOnly(ctx context.Context, tileNumber types.TileNumber, q *query.Query) (<-chan paramtools.Params, error) {
	ret := _mock.Called(ctx, tileNumber, q)

	if len(ret) == 0 {
		panic("no return value specified for QueryTracesIDOnly")
	}

	var r0 <-chan paramtools.Params
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TileNumber, *query.Query) (<-chan paramtools.Params, error)); ok {
		return returnFunc(ctx, tileNumber, q)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TileNumber, *query.Query) <-chan paramtools.Params); ok {
		r0 = returnFunc(ctx, tileNumber, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan paramtools.Params)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TileNumber, *query.Query) error); ok {
		r1 = returnFunc(ctx, tileNumber, q)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TraceStore_QueryTracesIDOnly_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryTracesIDOnly'
type TraceStore_QueryTracesIDOnly_Call struct {
	*mock.Call
}

// QueryTracesIDOnly is a helper method to define mock.On call
//   - ctx context.Context
//   - tileNumber types.TileNumber
//   - q *query.Query
func (_e *TraceStore_Expecter) QueryTracesIDOnly(ctx interface{}, tileNumber interface{}, q interface{}) *TraceStore_QueryTracesIDOnly_Call {
	return &TraceStore_QueryTracesIDOnly_Call{Call: _e.mock.On("QueryTracesIDOnly", ctx, tileNumber, q)}
}

func (_c *TraceStore_QueryTracesIDOnly_Call) Run(run func(ctx context.Context, tileNumber types.TileNumber, q *query.Query)) *TraceStore_QueryTracesIDOnly_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 types.TileNumber
		if args[1] != nil {
			arg1 = args[1].(types.TileNumber)
		}
		var arg2 *query.Query
		if args[2] != nil {
			arg2 = args[2].(*query.Query)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *TraceStore_QueryTracesIDOnly_Call) Return(paramsCh <-chan paramtools.Params, err error) *TraceStore_QueryTracesIDOnly_Call {
	_c.Call.Return(paramsCh, err)
	return _c
}

func (_c *TraceStore_QueryTracesIDOnly_Call) RunAndReturn(run func(ctx context.Context, tileNumber types.TileNumber, q *query.Query) (<-chan paramtools.Params, error)) *TraceStore_QueryTracesIDOnly_Call {
	_c.Call.Return(run)
	return _c
}

// ReadTraces provides a mock function for the type TraceStore
func (_mock *TraceStore) ReadTraces(ctx context.Context, tileNumber types.TileNumber, keys []string) (types.TraceSet, []provider.Commit, error) {
	ret := _mock.Called(ctx, tileNumber, keys)

	if len(ret) == 0 {
		panic("no return value specified for ReadTraces")
	}

	var r0 types.TraceSet
	var r1 []provider.Commit
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TileNumber, []string) (types.TraceSet, []provider.Commit, error)); ok {
		return returnFunc(ctx, tileNumber, keys)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TileNumber, []string) types.TraceSet); ok {
		r0 = returnFunc(ctx, tileNumber, keys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.TraceSet)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TileNumber, []string) []provider.Commit); ok {
		r1 = returnFunc(ctx, tileNumber, keys)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]provider.Commit)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, types.TileNumber, []string) error); ok {
		r2 = returnFunc(ctx, tileNumber, keys)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// TraceStore_ReadTraces_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadTraces'
type TraceStore_ReadTraces_Call struct {
	*mock.Call
}

// ReadTraces is a helper method to define mock.On call
//   - ctx context.Context
//   - tileNumber types.TileNumber
//   - keys []string
func (_e *TraceStore_Expecter) ReadTraces(ctx interface{}, tileNumber interface{}, keys interface{}) *TraceStore_ReadTraces_Call {
	return &TraceStore_ReadTraces_Call{Call: _e.mock.On("ReadTraces", ctx, tileNumber, keys)}
}

func (_c *TraceStore_ReadTraces_Call) Run(run func(ctx context.Context, tileNumber types.TileNumber, keys []string)) *TraceStore_ReadTraces_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 types.TileNumber
		if args[1] != nil {
			arg1 = args[1].(types.TileNumber)
		}
		var arg2 []string
		if args[2] != nil {
			arg2 = args[2].([]string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *TraceStore_ReadTraces_Call) Return(traceSet types.TraceSet, commits []provider.Commit, err error) *TraceStore_ReadTraces_Call {
	_c.Call.Return(traceSet, commits, err)
	return _c
}

func (_c *TraceStore_ReadTraces_Call) RunAndReturn(run func(ctx context.Context, tileNumber types.TileNumber, keys []string) (types.TraceSet, []provider.Commit, error)) *TraceStore_ReadTraces_Call {
	_c.Call.Return(run)
	return _c
}

// ReadTracesForCommitRange provides a mock function for the type TraceStore
func (_mock *TraceStore) ReadTracesForCommitRange(ctx context.Context, keys []string, begin types.CommitNumber, end types.CommitNumber) (types.TraceSet, []provider.Commit, error) {
	ret := _mock.Called(ctx, keys, begin, end)

	if len(ret) == 0 {
		panic("no return value specified for ReadTracesForCommitRange")
	}

	var r0 types.TraceSet
	var r1 []provider.Commit
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string, types.CommitNumber, types.CommitNumber) (types.TraceSet, []provider.Commit, error)); ok {
		return returnFunc(ctx, keys, begin, end)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string, types.CommitNumber, types.CommitNumber) types.TraceSet); ok {
		r0 = returnFunc(ctx, keys, begin, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.TraceSet)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []string, types.CommitNumber, types.CommitNumber) []provider.Commit); ok {
		r1 = returnFunc(ctx, keys, begin, end)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]provider.Commit)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, []string, types.CommitNumber, types.CommitNumber) error); ok {
		r2 = returnFunc(ctx, keys, begin, end)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// TraceStore_ReadTracesForCommitRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadTracesForCommitRange'
type TraceStore_ReadTracesForCommitRange_Call struct {
	*mock.Call
}

// ReadTracesForCommitRange is a helper method to define mock.On call
//   - ctx context.Context
//   - keys []string
//   - begin types.CommitNumber
//   - end types.CommitNumber
func (_e *TraceStore_Expecter) ReadTracesForCommitRange(ctx interface{}, keys interface{}, begin interface{}, end interface{}) *TraceStore_ReadTracesForCommitRange_Call {
	return &TraceStore_ReadTracesForCommitRange_Call{Call: _e.mock.On("ReadTracesForCommitRange", ctx, keys, begin, end)}
}

func (_c *TraceStore_ReadTracesForCommitRange_Call) Run(run func(ctx context.Context, keys []string, begin types.CommitNumber, end types.CommitNumber)) *TraceStore_ReadTracesForCommitRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []string
		if args[1] != nil {
			arg1 = args[1].([]string)
		}
		var arg2 types.CommitNumber
		if args[2] != nil {
			arg2 = args[2].(types.CommitNumber)
		}
		var arg3 types.CommitNumber
		if args[3] != nil {
			arg3 = args[3].(types.CommitNumber)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *TraceStore_ReadTracesForCommitRange_Call) Return(traceSet types.TraceSet, commits []provider.Commit, err error) *TraceStore_ReadTracesForCommitRange_Call {
	_c.Call.Return(traceSet, commits, err)
	return _c
}

func (_c *TraceStore_ReadTracesForCommitRange_Call) RunAndReturn(run func(ctx context.Context, keys []string, begin types.CommitNumber, end types.CommitNumber) (types.TraceSet, []provider.Commit, error)) *TraceStore_ReadTracesForCommitRange_Call {
	_c.Call.Return(run)
	return _c
}

// StartBackgroundMetricsGathering provides a mock function for the type TraceStore
func (_mock *TraceStore) StartBackgroundMetricsGathering() {
	_mock.Called()
	return
}

// TraceStore_StartBackgroundMetricsGathering_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartBackgroundMetricsGathering'
type TraceStore_StartBackgroundMetricsGathering_Call struct {
	*mock.Call
}

// StartBackgroundMetricsGathering is a helper method to define mock.On call
func (_e *TraceStore_Expecter) StartBackgroundMetricsGathering() *TraceStore_StartBackgroundMetricsGathering_Call {
	return &TraceStore_StartBackgroundMetricsGathering_Call{Call: _e.mock.On("StartBackgroundMetricsGathering")}
}

func (_c *TraceStore_StartBackgroundMetricsGathering_Call) Run(run func()) *TraceStore_StartBackgroundMetricsGathering_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TraceStore_StartBackgroundMetricsGathering_Call) Return() *TraceStore_StartBackgroundMetricsGathering_Call {
	_c.Call.Return()
	return _c
}

func (_c *TraceStore_StartBackgroundMetricsGathering_Call) RunAndReturn(run func()) *TraceStore_StartBackgroundMetricsGathering_Call {
	_c.Run(run)
	return _c
}

// TileNumber provides a mock function for the type TraceStore
func (_mock *TraceStore) TileNumber(commitNumber types.CommitNumber) types.TileNumber {
	ret := _mock.Called(commitNumber)

	if len(ret) == 0 {
		panic("no return value specified for TileNumber")
	}

	var r0 types.TileNumber
	if returnFunc, ok := ret.Get(0).(func(types.CommitNumber) types.TileNumber); ok {
		r0 = returnFunc(commitNumber)
	} else {
		r0 = ret.Get(0).(types.TileNumber)
	}
	return r0
}

// TraceStore_TileNumber_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TileNumber'
type TraceStore_TileNumber_Call struct {
	*mock.Call
}

// TileNumber is a helper method to define mock.On call
//   - commitNumber types.CommitNumber
func (_e *TraceStore_Expecter) TileNumber(commitNumber interface{}) *TraceStore_TileNumber_Call {
	return &TraceStore_TileNumber_Call{Call: _e.mock.On("TileNumber", commitNumber)}
}

func (_c *TraceStore_TileNumber_Call) Run(run func(commitNumber types.CommitNumber)) *TraceStore_TileNumber_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 types.CommitNumber
		if args[0] != nil {
			arg0 = args[0].(types.CommitNumber)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *TraceStore_TileNumber_Call) Return(tileNumber types.TileNumber) *TraceStore_TileNumber_Call {
	_c.Call.Return(tileNumber)
	return _c
}

func (_c *TraceStore_TileNumber_Call) RunAndReturn(run func(commitNumber types.CommitNumber) types.TileNumber) *TraceStore_TileNumber_Call {
	_c.Call.Return(run)
	return _c
}

// TileSize provides a mock function for the type TraceStore
func (_mock *TraceStore) TileSize() int32 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TileSize")
	}

	var r0 int32
	if returnFunc, ok := ret.Get(0).(func() int32); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int32)
	}
	return r0
}

// TraceStore_TileSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TileSize'
type TraceStore_TileSize_Call struct {
	*mock.Call
}

// TileSize is a helper method to define mock.On call
func (_e *TraceStore_Expecter) TileSize() *TraceStore_TileSize_Call {
	return &TraceStore_TileSize_Call{Call: _e.mock.On("TileSize")}
}

func (_c *TraceStore_TileSize_Call) Run(run func()) *TraceStore_TileSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TraceStore_TileSize_Call) Return(n int32) *TraceStore_TileSize_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *TraceStore_TileSize_Call) RunAndReturn(run func() int32) *TraceStore_TileSize_Call {
	_c.Call.Return(run)
	return _c
}

// TraceCount provides a mock function for the type TraceStore
func (_mock *TraceStore) TraceCount(ctx context.Context, tileNumber types.TileNumber) (int64, error) {
	ret := _mock.Called(ctx, tileNumber)

	if len(ret) == 0 {
		panic("no return value specified for TraceCount")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TileNumber) (int64, error)); ok {
		return returnFunc(ctx, tileNumber)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.TileNumber) int64); ok {
		r0 = returnFunc(ctx, tileNumber)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, types.TileNumber) error); ok {
		r1 = returnFunc(ctx, tileNumber)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// TraceStore_TraceCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TraceCount'
type TraceStore_TraceCount_Call struct {
	*mock.Call
}

// TraceCount is a helper method to define mock.On call
//   - ctx context.Context
//   - tileNumber types.TileNumber
func (_e *TraceStore_Expecter) TraceCount(ctx interface{}, tileNumber interface{}) *TraceStore_TraceCount_Call {
	return &TraceStore_TraceCount_Call{Call: _e.mock.On("TraceCount", ctx, tileNumber)}
}

func (_c *TraceStore_TraceCount_Call) Run(run func(ctx context.Context, tileNumber types.TileNumber)) *TraceStore_TraceCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 types.TileNumber
		if args[1] != nil {
			arg1 = args[1].(types.TileNumber)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *TraceStore_TraceCount_Call) Return(n int64, err error) *TraceStore_TraceCount_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *TraceStore_TraceCount_Call) RunAndReturn(run func(ctx context.Context, tileNumber types.TileNumber) (int64, error)) *TraceStore_TraceCount_Call {
	_c.Call.Return(run)
	return _c
}

// WriteTraces provides a mock function for the type TraceStore
func (_mock *TraceStore) WriteTraces(ctx context.Context, commitNumber types.CommitNumber, params []paramtools.Params, values []float32, paramset paramtools.ParamSet, source string, timestamp time.Time) error {
	ret := _mock.Called(ctx, commitNumber, params, values, paramset, source, timestamp)

	if len(ret) == 0 {
		panic("no return value specified for WriteTraces")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, types.CommitNumber, []paramtools.Params, []float32, paramtools.ParamSet, string, time.Time) error); ok {
		r0 = returnFunc(ctx, commitNumber, params, values, paramset, source, timestamp)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// TraceStore_WriteTraces_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteTraces'
type TraceStore_WriteTraces_Call struct {
	*mock.Call
}

// WriteTraces is a helper method to define mock.On call
//   - ctx context.Context
//   - commitNumber types.CommitNumber
//   - params []paramtools.Params
//   - values []float32
//   - paramset paramtools.ParamSet
//   - source string
//   - timestamp time.Time
func (_e *TraceStore_Expecter) WriteTraces(ctx interface{}, commitNumber interface{}, params interface{}, values interface{}, paramset interface{}, source interface{}, timestamp interface{}) *TraceStore_WriteTraces_Call {
	return &TraceStore_WriteTraces_Call{Call: _e.mock.On("WriteTraces", ctx, commitNumber, params, values, paramset, source, timestamp)}
}

func (_c *TraceStore_WriteTraces_Call) Run(run func(ctx context.Context, commitNumber types.CommitNumber, params []paramtools.Params, values []float32, paramset paramtools.ParamSet, source string, timestamp time.Time)) *TraceStore_WriteTraces_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 types.CommitNumber
		if args[1] != nil {
			arg1 = args[1].(types.CommitNumber)
		}
		var arg2 []paramtools.Params
		if args[2] != nil {
			arg2 = args[2].([]paramtools.Params)
		}
		var arg3 []float32
		if args[3] != nil {
			arg3 = args[3].([]float32)
		}
		var arg4 paramtools.ParamSet
		if args[4] != nil {
			arg4 = args[4].(paramtools.ParamSet)
		}
		var arg5 string
		if args[5] != nil {
			arg5 = args[5].(string)
		}
		var arg6 time.Time
		if args[6] != nil {
			arg6 = args[6].(time.Time)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
			arg6,
		)
	})
	return _c
}

func (_c *TraceStore_WriteTraces_Call) Return(err error) *TraceStore_WriteTraces_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *TraceStore_WriteTraces_Call) RunAndReturn(run func(ctx context.Context, commitNumber types.CommitNumber, params []paramtools.Params, values []float32, paramset paramtools.ParamSet, source string, timestamp time.Time) error) *TraceStore_WriteTraces_Call {
	_c.Call.Return(run)
	return _c
}
