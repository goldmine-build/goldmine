package resolver

import (
	"log"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/repo"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

const (
	// gazelleExtensionName is the extension name passed to Gazelle.
	//
	// This name can be used to enable or disable this Gazelle extension via the --lang flag, e.g.
	//
	//     $ bazel run gazelle -- update --lang go,frontend
	gazelleExtensionName = "frontend"

	// Namespace under which NPM modules are exposed.
	//
	// This must be kept in sync with the npm_install rule in the WORKSPACE file.
	npmBazelNamespace = "infra-sk_npm"
)

// Resolver implements the resolve.Resolver interface.
//
// Interface documentation:
//
// Resolver is an interface that language extensions can implement to resolve
// dependencies in rules they generate.
type Resolver struct {
	// sassImportsToDeps maps Sass imports to the rules that provide those imports.
	sassImportsToDeps map[string]map[ruleKindAndLabel]bool

	// tsImportsToDeps maps TypeScript imports to rules that provide those imports.
	tsImportsToDeps map[string]map[ruleKindAndLabel]bool
}

// ruleAKindAndLabel is a (rule kind, rule label) pair (e.g. "ts_library", "//path/to:my_ts_lib").
type ruleKindAndLabel struct {
	kind  string
	label label.Label
}

// noRuleKindAndLabel is the zero value of ruleKindAndLabel. Used as a sentinel value when no rule
// is found.
var noRuleKindAndLabel = ruleKindAndLabel{}

// indexImportsProvidedByRule indexes the imports provided by the given rule. The rule can be later
// obtained from an import via the findRuleThatProvidesImport method.
func (rslv *Resolver) indexImportsProvidedByRule(lang string, importPaths []string, ruleKind string, ruleLabel label.Label) {
	if lang != "sass" && lang != "ts" {
		log.Panicf("Unknown language: %q.", lang)
	}

	if rslv.sassImportsToDeps == nil {
		rslv.sassImportsToDeps = map[string]map[ruleKindAndLabel]bool{}
	}
	if rslv.tsImportsToDeps == nil {
		rslv.tsImportsToDeps = map[string]map[ruleKindAndLabel]bool{}
	}

	importsToDeps := rslv.sassImportsToDeps
	if lang == "ts" {
		importsToDeps = rslv.tsImportsToDeps
	}

	for _, importPath := range importPaths {
		if importsToDeps[importPath] == nil {
			importsToDeps[importPath] = map[ruleKindAndLabel]bool{}
		}
		rkal := ruleKindAndLabel{kind: ruleKind, label: ruleLabel}
		importsToDeps[importPath][rkal] = true
	}
}

// findRuleThatProvidesImport returns the rule that provides the given import, provided it was
// indexed via an earlier call to indexImportsProvidedByRule.
func (rslv *Resolver) findRuleThatProvidesImport(lang string, importPath string, fromRuleKind string, fromRuleLabel label.Label) ruleKindAndLabel {
	if lang != "sass" && lang != "ts" {
		log.Panicf("Unknown language: %q.", lang)
	}

	importsToDeps := rslv.sassImportsToDeps
	if lang == "ts" {
		importsToDeps = rslv.tsImportsToDeps
	}

	var candidates []ruleKindAndLabel
	if importsToDeps[importPath] != nil {
		for c := range importsToDeps[importPath] {
			candidates = append(candidates, c)
		}
	}

	if len(candidates) == 0 {
		log.Printf("Could not find any rules that satisfy import %q from %s (%s)", importPath, fromRuleLabel, fromRuleKind)
		return noRuleKindAndLabel
	}

	if len(candidates) > 1 {
		log.Printf("Multiple rules satisfy import %q from %s (%s): %s (%s), %s (%s)", importPath, fromRuleLabel, fromRuleKind, candidates[0].label, candidates[0].kind, candidates[1].label, candidates[1].kind)
		return noRuleKindAndLabel
	}

	return candidates[0]
}

// Name implements the resolve.Resolver interface.
//
// Interface documentation:
//
// Name returns the name of the language. This should be a prefix of the
// kinds of rules generated by the language, e.g., "go" for the Go extension
// since it generates "go_library" rules.
func (rslv *Resolver) Name() string {
	return gazelleExtensionName
}

// Imports implements the resolve.Resolver interface.
//
// Imports extracts and indexes the imports provided by the given rule. Gazelle calls this method
// once for each rule in the repository that this Gazelle extension understands (i.e. all front-end
// rules).
//
// For example, if Imports is passed a ts_library rule with label "//path/to:my_lib" and sources
// "foo.ts" and "bar.ts", then presumably said rule could satisfy TypeScript imports such as
// "import * from 'path/to/foo'" or "import 'path/to/bar'". In this example, Imports should return
// a slice with two resolve.ImportSpec structs, one for each of "path/to/foo" and "path/to/bar".
//
// Gazelle uses the returned resolve.ImportSpec structs to build a resolve.RuleIndex struct, which
// maps imports (e.g. "path/to/foo") to the labels of the rules that provide them (e.g.
// "//path/to:my_lib"). This index is passed to the Resolve method (implemented below), in which we
// resolve the dependencies of all the rules generated by this Gazelle extension (i.e. we populate
// their deps attributes).
//
// However, the resolve.RuleIndex struct is insufficient to resolve the dependencies of rules such
// as sk_element, which has multiple types of dependencies (ts_deps, sass_deps, sk_element_deps).
// We need to know the kind of a dependency (e.g. "ts_library", "sass_library", "sk_element"), in
// addition to its label, before we can add it to one of the *_deps arguments, but the
// resolve.RuleIndex struct only provides the latter.
//
// For this reason, this Gazelle extension ignores the resolve.RuleIndex struct. Instead, we build
// our own index with all the information we need (see fields sassImportsToDeps and
// tsImportsToDeps).
//
// Therefore, this method always returns an empty slice, which results in an empty
// resolve.RuleIndex, but that is OK because we do not use it.
func (rslv *Resolver) Imports(c *config.Config, r *rule.Rule, f *rule.File) []resolve.ImportSpec {
	// TODO(lovisolo): Implement.

	return []resolve.ImportSpec{}
}

// Embeds implements the resolve.Resolver interface.
func (rslv *Resolver) Embeds(r *rule.Rule, from label.Label) []label.Label { return []label.Label{} }

// Resolve implements the resolve.Resolver interface.
//
// Resolve takes a (rule, ImportsParsedFromRuleSources) pair generated by Language.GenerateRules()
// and resolves the rule's dependencies based on its imports. It populates the rule's deps argument
// (or ts_deps, sass_deps and sk_element_deps arguments in the case of sk_element and sk_page rules)
// with the result of mapping each import to the label of a rule that provides the import. It does
// so by leveraging the index built in the Imports method.
//
// Gazelle calls this method once for each (rule, ImportsParsedFromRuleSources) pair generated by
// successive calls to Language.GenerateRules(). Gazelle calls this method after all imports in the
// repository have been indexed via successive calls to the Imports method.
func (rslv *Resolver) Resolve(c *config.Config, _ *resolve.RuleIndex, _ *repo.RemoteCache, r *rule.Rule, imports interface{}, from label.Label) {
	// TODO(lovisolo): Implement.
}

var _ resolve.Resolver = &Resolver{}
